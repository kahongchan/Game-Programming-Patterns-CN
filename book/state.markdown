^title 狀態模式 State
^section Design Patterns Revisited

懺悔時間：我有些越界，將太多的東西打包到了這章中。
它表面上關於<a href="http://en.wikipedia.org/wiki/State_pattern" class="gof-pattern">狀態模式</a>，
但我無法只討論它和遊戲，而不涉及更加基礎的*有限狀態機*（FSMs）。
但是一旦講了那個，我發現也想要介紹*層次狀態機*和*下推自動機*。

有很多要講，我會盡可能簡短，這裏的示例代碼留下了一些你需要自己填補的細節。
我希望它們仍然足夠清晰，能讓你獲取一份全景圖。

<span name="two-camps"></span>
如果你從來沒有聽說過狀態機，不要難過。
雖然在AI和編譯器程序方面很出名，但它在其他編程圈就沒那麼知名了。
我認爲應該有更多人知道它，所以在這裏我將其運用在不同的問題上。

<aside name="two-camps">

這些狀態機術語來自人工智能的早期時代。
在五十年代到六十年代，很多AI研究關注於語言處理。
很多現在用於分析程序語言的技術在當時是發明出來分析人類語言的。

</aside>

## 感同身受

假設我們在完成一個卷軸平臺遊戲。
現在的工作是實現玩家在遊戲世界中操作的女英雄。
這就意味着她需要對玩家的輸入做出響應。按B鍵她應該跳躍。簡單實現如下：

^code spaghetti-1

看到漏洞了嗎？

<span name="landing"></span>
沒有東西阻止“空中跳躍”——當角色在空中時狂按B，她就會浮空。
簡單的修復方法是給`Heroine`增加`isJumping_`布爾字段，追蹤它跳躍的狀態。然後這樣做：

^code spaghetti-2

<aside name="landing">

這裏也應該有在英雄接觸到地面時將`isJumping_`設回`false`的代碼。
我在這裏爲了簡明沒有寫。

</aside>

接下來，當玩家按下下方向鍵時，如果角色在地上，我們想要她臥倒，而鬆開按鍵時站起來：

^code spaghetti-3

這次看到漏洞了嗎？

通過這個代碼，玩家可以：

1. 按下鍵臥倒。
2. 按B從臥倒狀態跳起。
3. 在空中放開下鍵。

英雄跳一半貼圖變成了站立時的貼圖。是時候增加另一個標識了……

^code spaghetti-4

下面，如果玩家在跳躍途中按下下方向鍵，英雄能夠做跳斬攻擊就太酷了：

^code spaghetti-5

又是檢查漏洞的時間了。找到了嗎？

跳躍時我們檢查了字段，防止了空氣跳，但是速降時沒有。又是另一個字段……

<span name="se"></span>
我們的實現方法很明顯有錯。
每次我們改動代碼時，就破壞些東西。
我們需要增加更多動作——*行走* 都還沒有加入呢——但以這種做法，完成之前就會造成一堆漏洞。

<aside name="se">

那些你崇拜的、看上去永遠能寫出完美代碼的程序員並不是超人。
相反，他們有*哪種*代碼易於出錯的直覺，然後避開。

複雜分支和可變狀態——隨時間改變的字段——是兩種易錯代碼，上面的例子覆蓋了兩者。

</aside>

## 有限狀態機前來救援

在經歷了上面的挫敗之後，把桌子掃空，只留下紙筆，我們開始畫流程圖。
你給英雄每件能做的事情都畫了一個盒子：站立，跳躍，俯臥，跳斬。
當角色在能響應按鍵的狀態時，你從那個盒子畫出一個箭頭，標記上按鍵，然後連接到她變到的狀態。

<img src="images/state-flowchart.png" alt="一張畫有盒子的圖表，盒子代表了站立，跳躍，俯臥和跳斬。標記了按鍵的按下和釋放的箭頭連接了這些盒子。" />

祝賀，你剛剛建好了一個*有限狀態機*。
它來自計算機科學的分支*自動理論*，那裏有很多著名的數據結構，包括著名的圖靈機。
FSMs是其中最簡單的成員。

<span name="adventure"></span>
要點是：

*  **你擁有狀態機所有可能*狀態*的集合。**
    在我們的例子中，是站立，跳躍，俯臥和速降。

*  **狀態機同時只能在*一個*狀態。**
    英雄不可能同時處於跳躍和站立狀態。事實上，防止這點是使用FSM的理由之一。

*  **一連串的*輸入*或*事件*被髮送給狀態機。**
    在我們的例子中，就是按鍵按下和鬆開。

*  **每個狀態都有*一系列的轉移*，每個轉移與輸入和另一狀態相關。**
    當輸入進來，如果它與當前狀態的某個轉移相匹配，機器轉換爲所指的狀態。

    舉個例子，在站立狀態時，按下下方向鍵轉換爲俯臥狀態。
    在跳躍時按下下方向鍵轉換爲速降。
    如果輸入在當前狀態沒有定義轉移，輸入就被忽視。

這就是核心部分的全部了：狀態，輸入，和轉移。
你可以用一張流程圖把它畫出來。不幸的是，編譯器不認識流程圖，
所以我們如何*實現*一個？
GoF的狀態模式是一個方法——我們會談到的——但先從簡單的開始。

<aside name="adventure">

對FSMs我最喜歡的類比是那種老式文字冒險遊戲，比如Zork。
你有個由屋子組成的世界，屋子彼此通過出口相連。你輸入像“去北方”的導航指令探索屋子。

這其實就是狀態機：每個屋子都是一個狀態。
你現在在的屋子是當前狀態。每個屋子的出口是它的轉移。
導航指令是輸入。

</aside>

## 枚舉和分支

`Heroine`類的問題在於它不合法地捆綁了一堆布爾量：
`isJumping_`和`isDucking_`不會同時爲真。
但有些標識同時只能有一個是`true`，這提示你真正需要的其實是`enum`（枚舉）。

在這個例子中的`enum`就是FSM的狀態的集合，所以讓我們這樣定義它：

^code enum

不需要一堆標識，`Heroine`只有一個`state_`狀態。
這裏我們同時改變了分支順序。在前面的代碼中，我們先判斷輸入，*然後* 判斷狀態。
這讓處理某個按鍵的代碼集中到了一處，但處理某個狀態的代碼分散到了各處。
我們想讓處理狀態的代碼聚在一起，所以先對狀態做分支。這樣的話：

^code state-switch

<span name="invalid"></span>
這看起來很普通，但是比起前面的代碼是個很大的進步。
我們仍有條件分支，但簡化了狀態變化，將它變成了字段。
處理同一狀態的所有代碼都聚到了一起。
這是實現狀態機最簡單的方法，在某些情況下，這也不錯。

<aside name="invalid">

重要的是，英雄不再會處於*不合法*狀態。
使用布爾標識，很多可能存在的值的組合是不合法的。
通過`enum`，每個值都是合法的。

</aside>

但是，你的問題也許超過了這個解法的能力範圍。
假設我們想增加一個動作動作，英雄可以俯臥一段時間充能，之後釋放一次特殊攻擊。
當她俯臥時，我們需要追蹤充能的持續時間。

<span name="update"></span>
我們爲`Heroine`添加了`chargeTime_`字段，記錄充能的時間長度。
假設我們已經有一個每幀都會調用的`update()`方法。在那裏，我們添加：

^code switch-update

<aside name="update">

如果你猜這就是<a href="update-method.html" class="pattern">更新方法</a>模式，恭喜你答對了！

</aside>

我們需要在她開始俯臥的時候重置計時器，所以我們修改`handleInput()`：

^code state-switch-reset

總而言之，爲了增加這個充能攻擊，我們需要修改兩個方法，
添加一個`chargeTime_`字段到`Heroine`，哪怕它只在俯臥時有意義。
我們更喜歡的是讓所有相關的代碼和數據都待在同一個地方。GoF完成了這個。

## 狀態模式

<span name="branch"></span>
對於那些思維模式深深沉浸在面向對象的人，每個條件分支都是使用動態分配的機會（在C++中叫做虛方法調用）。
我覺得那就太過於複雜化了。有時候一個`if`就能滿足你的需要了。

<aside name="branch">

這裏有個歷史遺留問題。
原先的面向對象傳教徒，比如寫《設計模式》的GoF和寫《重構》的Martin Fowler都使用Smalltalk。
那裏，`ifThen:`只是個由你在一定情況下使用的方法，該方法在`true`和`false`對象中以不同的方式實現。

</aside>

但是在我們的例子中，面向對象確實是一個更好的方案。
這帶領我們走向狀態模式。GoF這樣描述狀態模式：

> 允許一個對象在其內部狀態發生變化時改變自己的行爲，該對象看起來好像修改了它的類型

這可沒太多幫助。我們的`switch`也完成了這一點。
它們描述的東西應用在英雄的身上實際是：

### 一個狀態接口

首先，我們爲狀態定義接口。
狀態相關的行爲——之前用`switch`的每一處——都成爲了接口中的虛方法。
在我們的例子中，那是`handleInput()`和`update()`：

^code heroine-state

### 爲每個狀態寫個類

對於每個狀態，我們定義一個類實現接口。它的方法定義了英雄在狀態的行爲。
換言之，從之前的`switch`中取出每個`case`，將它們移動到狀態類中。舉個例子：

^code ducking-state

注意我們也將`chargeTime_`移出了`Heroine`，放到了`DuckingState`類中。
這很好——那部分數據只在這個狀態有用，現在我們的對象模型顯式反映了這一點。

### 狀態委託

接下來，向`Heroine`添加指向當前狀態的指針，放棄龐大的`switch`，轉向狀態委託：

<span name="delegate"></span>

^code gof-heroine

爲了“改變狀態”，我們只需要將`state_`聲明指向不同的`HeroineState`對象。
這就是狀態模式的全部了。

<aside name="delegate">

這看上去有些像<a href="http://en.wikipedia.org/wiki/Strategy_pattern" class="gof-pattern">策略</a>模式和<a href="type-object.html"class="pattern">類型對象</a>模式。
在三者中，你都有一個主對象委託給下屬。區別在於*意圖*。

* 在策略模式中，目標是解耦主類和它的部分行爲。
* 在類型對象中，目標是通過*共享*一個對相同類型對象的引用，讓一*系列*對象行爲相近。
* 在狀態模式中，目標是讓主對象通過*改變*委託的對象，來*改變*它的行爲。

</aside>

## 狀態對象在哪裏？

我這裏掩掩藏了一些細節。爲了改變狀態，我們需要聲明`state_`指向新的狀態，
但那個新狀態又是從哪裏來呢？
在`enum`實現中，這都不用過腦子——`enum`實際上就像數字一樣。
但是現在狀態是類了，意味着我們需要指向實例。通常這有兩種方案：

### 靜態狀態

<span name="fn"></span>

如果狀態對象沒有其他數據字段，
那麼它存儲的唯一數據就是指向虛方法表的指針，用來調用它的方法。
在這種情況下，沒理由產生多個實例。畢竟每個實例都完全一樣。

<aside name="fn">

如果你的狀態沒有字段，只有*一個*虛方法，你可以再簡化這個模式。
將每個狀態*類*替換成狀態*函數*——只是一個普通的頂層函數。
然後，主類中的`state_`字段變成一個簡單的函數指針。

</aside>

在那種情況下，你可以用一個*靜態*實例。
哪怕你有一堆FSM同時在同一狀態上運行，它們也能指向同一實例，因爲狀態沒有與狀態機相關的部分。

<span name="flyweight"></span>

<aside name="flyweight">

這是<a href="flyweight.html" class="gof-pattern">享元</a>模式。

</aside>

在*哪裏*放置靜態實例取決於你。找一個合理的地方。
沒什麼特殊的理由，在這裏我將它放在狀態基類中。

^code heroine-static-states

每個靜態字段都是遊戲狀態類的一個實例。爲了讓英雄跳躍，站立狀態會這樣做：

^code jump

### 實例化狀態

有時沒那麼容易。靜態狀態對俯臥狀態不起作用。
它有一個`chargeTime_`字段，與正在俯臥的英雄特定相關。
在遊戲中，如果只有一個英雄，那也行，但是如果要添加雙人合作，同時在屏幕上有兩個英雄，就有麻煩了。

<span name="fragment"></span>
在那種情況下，轉換時需要創建狀態對象。
這需要每個FSM擁有自己的狀態實例。如果我們分配*新*狀態，
那意味着我們需要釋放*當前的*狀態。
在這裏要小心，由於觸發變化的代碼是當前狀態中的方法，需要刪除`this`，因此需要小心從事。

相反，我們允許`HeroineState`中的`handleInput()`返回一個新狀態。
如果它那麼做了，`Heroine`會刪除舊的，然後換成新的，就像這樣：

^code swap-instance

這樣，直到從之前的狀態返回，我們才需要刪除它。
現在，站立狀態可以通過創建新實例轉換爲俯臥狀態：

^code duck

如果可以，我傾向於使用靜態狀態，因爲它們不會在狀態轉換時消耗太多的內存和CPU。
但是，對於更*多狀態的事物*，需要耗費一些精力來實現。

<aside name="fragment">

當你爲狀態動態分配內存時，你也許會擔心碎片。
<a href="object-pool.html" class="pattern">對象池</a>模式可以幫上忙。

</aside>

## 入口行爲和出口行爲

狀態模式的目標是將狀態的行爲和數據封裝到單一類中。
我們完成了一部分，但是還有一些未了之事。

當英雄改變狀態時，我們也改變她的貼圖。
現在，那部分代碼在她轉換*前*的狀態中。
當她從俯臥轉爲站立，俯臥狀態修改了她的貼圖：

^code enter-standing-before

我們想做的是，每個狀態控制自己的貼圖。這可以通過給狀態一個*入口行爲*來實現：

^code standing-with-enter

在`Heroine`中，我們將處理狀態改變的代碼移動到新狀態上調用：

^code change-state

這讓我們將俯臥代碼簡化爲：

^code enter-standing

它做的所有事情就是轉換到站立狀態，站立狀態控制貼圖。
現在我們的狀態真正地封裝了。
關於入口行爲的好事就是，當你進入狀態時，不必關心你是從哪個狀態轉換*來的*。

大多數真正的狀態圖都有轉爲同一狀態的多個轉移。
舉個例子，英雄在跳躍或跳斬後進入站立狀態。
這意味着我們在轉換髮生的最後重複相同的代碼。
入口行爲很好地解決了這一點。

我們能，當然，擴展並支持*出口行爲*。
這是在我們*離開*現有狀態，轉換到新狀態之前調用的方法。

## 有什麼收穫？

我花了這麼長時間向您推銷FSMs，現在我們來捋一捋。
我到現在講的都是真的，FSM能很好地解決一些問題。但它們最大的優點也是它們最大的缺點。

<span name="turing"></span>
狀態機通過使用有約束的結構來理清雜亂的代碼。
你只需一個固定狀態的集合，單一的當前狀態，和一些硬編碼的轉換。

<aside name="turing">

一個有限狀態機甚至不是*圖靈完全的*。
自動理論用一系列抽象模型描述計算，每種都比之前的複雜。
*圖靈機* 是其中最具有表現力的模型之一。

“圖靈完全”意味着一個系統（通常是編程語言）足以在內部實現一個圖靈機，
也就意味着，在某種程度上，所有的圖靈完全具有同樣的表現力。
FSMs不夠靈活，並不在其中。

</aside>

如果你需要爲更復雜的東西使用狀態機，比如遊戲AI，你會撞到這個模型的限制上。
感謝上天，我們的前輩找到了一些方法來避免這些限制。我會在這一章的最後簡單地瀏覽一下它們。

## 併發狀態機

我們決定賦予英雄拿槍的能力。
當她拿着槍的時候，她還是能做她之前的任何事情：跑動，跳躍，跳斬，等等。
但是她在做這些的同時也要能開火。

如果我們執着於FSM，我們需要*翻倍*現有狀態。
對於每個現有狀態，我們需要另一個她持槍狀態：站立，持槍站立，跳躍，持槍跳躍，
你知道我的意思了吧。

多加幾種武器，狀態就會指數爆炸。
不但增加了大量的狀態，也增加了大量的冗餘：
持槍和不持槍的狀態是完全一樣的，只是多了一點負責射擊的代碼。

<span name="combination"></span>
問題在於我們將兩種狀態綁定到了一個狀態機上——她*做的*和她*攜帶的*。
爲了處理所有可能的組合，我們需要爲每一*對*組合寫一個狀態。
修復方法很明顯：使用兩個單獨的狀態機。

<aside name="combination">

如果她在做什麼有*n*個狀態，而她攜帶了什麼有*m*個狀態，要塞到一個狀態機中，
我們需要*n &times; m*個狀態。使用兩個狀態機，就只有*n + m*個。

</aside>

我們保留之前記錄她在做什麼的狀態機，不用管它。
然後定義她攜帶了什麼的單獨狀態機。
`Heroine`將會有*兩個*“狀態”引用，每個對應一個狀態機，就像這樣：

<span name="equip-state"></span>

^code two-states

<aside name="equip-state">

爲了便於說明，她的裝備也使用了狀態模式。
在實踐中，由於裝備只有兩個狀態，一個布爾標識就夠了。

</aside>

當英雄把輸入委託給了狀態，兩個狀態都需要委託：

<span name="consume"></span>

^code handle-two-inputs

<aside name="consume">

功能更完備的系統也許能讓狀態機*銷燬*輸入，這樣其他狀態機就不會收到了。
這能阻止兩個狀態機響應同一輸入。

</aside>

每個狀態機之後都能響應輸入，發生行爲，獨立於其它機器改變狀態。
當兩個狀態集合幾乎沒有聯繫的時候，它工作得不錯。

在實踐中，你會發現狀態有時需要交互。
舉個例子，也許她在跳躍時不能開火，或者她在持槍時不能跳斬攻擊。
爲了完成這個，你也許會在狀態的代碼中做一些粗糙的`if`測試*其他*狀態來協同，
這不是最優雅的解決方案，但這可以搞定工作。

## 分層狀態機

再充實一下英雄的行爲，她可能會有更多相似的狀態。
舉個例子，她也許有站立、行走、奔跑和滑鏟狀態。在這些狀態中，按B跳，按下蹲。

如果使用簡單的狀態機實現，我們在每個狀態中的都重複了代碼。
如果我們能夠實現一次，在多個狀態間重用就好了。

<span name="inheritance"></span>
如果這是面向對象的代碼而不是狀態機的，在狀態間分享代碼的方式是通過繼承。
我們可以爲“在地面上”定義一個類處理跳躍和速降。
站立、行走、奔跑和滑鏟都從它繼承，然後增加各自的附加行爲。

<aside name="inheritance">

它的影響有好有壞。
繼承是一種有力的代碼重用工具，但也在兩塊代碼間建立了非常強的耦合。
這是重錘，所以請小心使用。

</aside>

你會發現，這是個被稱爲*分層狀態機*的通用結構。
狀態可以有*父狀態*（這讓它變爲*子狀態*）。
當一個事件進來，如果子狀態沒有處理，它就會交給鏈上的父狀態。
換言之，它像重載的繼承方法那樣運作。

事實上，如果我們使用狀態模式實現FSM，我們可以使用繼承來實現層次。
定義一個基類作爲父狀態：

^code on-ground

每個子狀態繼承它：

^code duck-on-ground

這當然不是唯一的實現層次的方法。
如果你沒有使用GoF的狀態模式，這可能不會有用。
相反，你可以顯式的使用狀態*棧*而不是單一狀態來表示當前狀態的父狀態鏈。

棧頂的狀態是當前狀態，在他下面是它的直接父狀態，
然後是*那個*父狀態的父狀態，以此類推。
當你需要狀態的特定行爲，你從棧的頂端開始，
然後向下尋找，直到某一個狀態處理了它。（如果到底也沒找到，就無視它。）

## 下推自動機

還有一種有限狀態機的擴展也用了狀態棧。
容易混淆的是，這裏的棧表示的是完全不同的事物，被用於解決不同的問題。

要解決的問題是有限狀態機沒有任何*歷史*的概念。
你記得*正在*什麼狀態中，但是不記得*曾在*什麼狀態。
沒有簡單的辦法重回上一狀態。

<span name="shared"></span>
舉個例子：早先，我們讓無畏英雄武裝到了牙齒。
當她開火時，我們需要新狀態播放開火動畫，發射子彈，產生視覺效果。
所以我們拼湊了一個`FiringState`，不管現在是什麼狀態，都能在按下開火按鈕時跳轉爲這個狀態。

<aside name="shared">

這個行爲在多個狀態間重複，也許是用層次狀態機重用代碼的好地方。

</aside>

問題在於她射擊*後*轉換到的狀態。
她可以在站立、奔跑、跳躍、跳斬時射擊。
當射擊結束，應該轉換爲她之前的狀態。

如果我們固執於純粹的FSM，我們就已經忘了她之前所處的狀態。
爲了追蹤之前的狀態，我們定義了很多幾乎完全一樣的類——站立開火，跑步開火，跳躍開火，諸如此類——
每個都有硬編碼的轉換，用來回到之前的狀態。

我們真正想要的是，它會*存儲*開火前所處的狀態，之後能*回想*起來。
自動理論又一次能幫上忙了，相關的數據結構被稱爲[*下推自動機*](http://en.wikipedia.org/wiki/Pushdown_automaton)。

有限狀態機有*一個*指向狀態的指針，下推自動機有*一棧*指針。
在FSM中，新狀態*代替*了之前的那個狀態。
下推自動機不僅能完成那個，還能給你兩個額外操作：

1. 你可以將新狀態*壓入*棧中。“當前的”狀態總是在棧頂，所以你能轉到新狀態。
  但它讓之前的狀態待在棧中而不是銷燬它。

2. 你可以*彈出*最上面的狀態。這個狀態會被銷燬，它下面的狀態成爲新狀態。

<img src="images/state-pushdown.png" alt="下推自動機的棧。起初只包含了一個站立狀態。然後一個開火狀態被壓入棧頂，當射擊結束，開火狀態被彈出。" />

這正是我們開火時需要的。我們創建*單一的*開火狀態。
當開火按鈕在其他狀態按下時，我們*壓入*開火狀態。
當開火動畫結束，我們*彈出*開火狀態，然後下推自動機自動轉回之前的狀態。

## 所以它們有多有用呢？

即使狀態機有這些常見的擴展，它們還是很受限制。
這讓今日遊戲AI移向了更加激動人心的領域，比如*[行爲樹][]*和*[規劃系統][]* 。
如果你關注複雜AI，這一整章只是爲了勾起你的食慾。
你需要閱讀其他書來滿足你的慾望。

[行爲樹]: http://web.archive.org/web/20140402204854/http://www.altdevblogaday.com/2011/02/24/introduction-to-behavior-trees/
[規劃系統]: http://web.media.mit.edu/~jorkin/goap.html

這不意味着有限狀態機，下推自動機，和其他簡單的系統沒有用。
它們是特定問題的好工具。有限狀態機在以下情況有用：

*  你有個實體，它的行爲基於一些內在狀態。
*  狀態可以被嚴格地分割爲相對較少的不相干項目。
*  實體響應一系列輸入或事件。

在遊戲中，狀態機因在AI中使用而聞名，但是它也常用於其他領域，
比如處理玩家輸入，導航菜單界面，分析文字，網絡協議以及其他異步行爲。
