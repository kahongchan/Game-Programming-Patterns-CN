^title 事件隊列 Event Queue
^section Decoupling Patterns

## 意圖

*解耦發出消息或事件的時間和處理它的時間。*

## 動機

<span name="message"></span>

除非還呆在一兩個沒有互聯網接入的犄角旮旯，否則你很可能已經聽說過“事件序列”了。
如果沒有，也許“消息隊列”或“事件循環”或“消息泵”可以讓你想起些什麼。
爲了喚醒你的記憶，讓我們瞭解幾個此模式的常見應用吧。

<aside name="message">

這章的大部分裏，我交替使用“事件”和“消息”。
在兩者的意義有區別時，我會表明的。

</aside>

### GUI事件循環

<span name="event-driven"></span>

如果你曾做過任何用戶界面編程，你就會很熟悉*事件*。
每當用戶與你的程序交互——點擊按鈕，拉出菜單，或者按個鍵——操作系統就會生成一個事件。
它會將這個對象扔給你的應用程序，你的工作就是獲取它然後將其與有趣的行爲相掛鉤。

<aside name="event-driven">

這個程序風格非常普遍，被認爲是一種編程範式：<a href="http://en.wikipedia.org/wiki/Event-driven_programming">*事件驅動編程*</a>。

</aside>

爲了獲取這些事件，代碼底層是*事件循環*。它大體上是這樣的：

^code event-loop

<span name="interrupt"></span>

調用`getNextEvent()`將一堆未處理的用戶輸入傳到應用程序中。
你將它導向事件處理器，之後應用魔術般獲得了生命。
有趣的部分是應用在*它*想要的時候*獲取*事件。
操作系統在用戶操作時不是直接跳轉到你應用的某處代碼。

<aside name="interrupt">

相反，操作系統的*中斷*確實是直接跳轉的。
當中斷髮生時，操作系統中斷應用在做的事，強制它跳到中斷處理。
這種唐突的做法是中斷很難使用的原因。

</aside>

這就意味着當用戶輸入進來時，它需要到某處去，
這樣操作系統在設備驅動報告輸入和應用去調用`getNextEvent()`之間不會漏掉它。
這個“某處”是一個*隊列*。

<img src="images/event-queue-loop.png" alt="一個事件隊列。操作系統入隊Shift鍵，下方向鍵，上方向鍵，以及點擊事件，getNextEvent()函數可以讓它們出隊。" />

當用戶輸入抵達時，操作系統將其添加到未處理事件的隊列中。
當你調用`getNextEvent()`時，它從隊列中獲取最舊的事件然後交給應用程序。

### 中心事件總線

<span name="game-loop"></span>

大多數遊戲不是像這樣事件驅動的，但是在遊戲中使用事件循環來支撐中樞系統是很常見的。
你通常聽到用“中心”“全局”“主體”描述它。
它通常被用於想要相互保持解耦的高層模塊間通信。

<aside name="game-loop">

如果你想知道*爲什麼*它們不是事件驅動的，看看<a href="game-loop.html" class="pattern">遊戲循環</a>一章。

</aside>

<span name="tutorial"></span>

假設遊戲有新手教程系統，在某些特定遊戲事件後顯示幫助框。
舉個例子，當玩家第一次擊敗了邪惡野獸，你想要一個顯示着“按X拿起戰利品！”的小氣泡。

<aside name="tutorial">

新手教程系統很難優雅地實現，大多數玩家很少使用遊戲內的幫助，所以這感覺上吃力不討好。
但對那些*使用*教程的玩家，這是無價之寶。

</aside>

遊戲玩法和戰鬥代碼也許像上面一樣複雜。
你最不想做的就是檢查一堆教程的觸發器。
相反，你可以使用中心事件隊列。
任何遊戲系統都可以發事件給隊列，這樣戰鬥代碼可以在砍倒敵人時發出“敵人死亡”事件。

<span name="blackboard"></span>

類似地，任何遊戲系統都能從隊列*接受*事件。
教程引擎在隊列中註冊自己，然後表明它想要收到“敵人死亡”事件。
用這種方式，敵人死了的消息從戰鬥系統傳到了教程引擎，而不需要這兩個系統直接知道對方的存在。

<aside name="blackboard">

實體可以發送和收到消息的模型很像AI界的<a href="http://en.wikipedia.org/wiki/Blackboard_system">blackboard systems</a>。

</aside>

<img src="images/event-queue-central.png" alt="一個戰鬥代碼和教程代碼都可以讀寫的中心事件隊列。" />

我本想將這個作爲這章其他部分的例子，但是我真的不喜歡這樣巨大的全局系統。
事件隊列不需要在整個遊戲引擎中溝通。在一個類或者領域中溝通就足夠有用了。

### 你說什麼？

所以說點別的，讓我們給遊戲添加一些聲音。
人類是視覺動物，但是聽覺強烈影響到情感系統和空間感覺。
正確模擬的回聲可以讓漆黑的屏幕感覺上是巨大的洞穴，而適時的小提琴慢板可以讓心絃拉響同樣的旋律。

<span name="singleton"></span>

爲了獲得優秀的音效表現，我們從最簡單的解決方法開始，看看結果如何。
添加一個“聲音引擎”，其中有使用標識符和音量就可以播放音樂的API：

<aside name="singleton">

我總是離<a href="singleton.html" class="gof-pattern">單例模式</a>遠遠的。
這是少數它可以使用的領域，因爲機器通常只有一個聲源系統。
我使用更簡單的方法，直接將方法定爲靜態。

</aside>

^code sync-api

它負責加載合適的聲音資源，找到可靠的播放頻道，然後啓動它。
這章不是關於某個平臺真實的音頻API，所以我會假設在其他某處魔術般實現了一個。
使用它，我們像這樣寫方法：

^code sync-impl

我們簽入以上代碼，創建一些聲音文件，然後在代碼中加入一些對`playSound()`的調用。
舉個例子，在UI代碼中，我們在選擇菜單項變化時播放一點小音效：

^code menu-bloop

這樣做了之後，我們注意到有時候你改變菜單項目，整個屏幕就會凍住幾幀。
我們遇到了第一個問題：

* **問題一：API在音頻引擎完成對請求的處理前阻塞了調用者。**

我們的`playSound()`方法是*同步*的——它在從播放器放出聲音前不會返回調用者。
如果聲音文件要從光盤上加載，那就得花費一定時間。
與此同時，遊戲的其他部分被卡住了。

現在忽視這一點，我們繼續。
在AI代碼中，我們增加了一個調用，在敵人承受玩家傷害時發出痛苦的低號。
沒有什麼比在虛擬的生物身上施加痛苦更能溫暖玩家心靈的了。

<span name="hatsworth"></span>

這能行，但是有時玩家打出暴擊，他在同一幀可以打到兩個敵人。
這讓遊戲同時要播放兩遍哀嚎。
如果你瞭解一些音頻的知識，那麼就知道要把兩個不同的聲音混合在一起，就要加和它們的波形。
當這兩個是*同一*波形時，它與*一個*聲音播放*兩倍響*是一樣的。那會很刺耳。

<aside name="hatsworth">

我在完成<a href="http://en.wikipedia.org/wiki/Henry_Hatsworth_in_the_Puzzling_Adventure">Henry Hatsworth in the Puzzling Adventure</a>時遇到了同樣的問題。解決方法和這裏的很相似。

</aside>

在Boss戰中有個相關的問題，當有一堆小怪跑動並製造傷害時。
硬件只能同時播放一定數量的音頻。當數量超過限度時，聲音就被忽視或者切斷了。

爲了處理這些問題，我們需要獲得音頻調用的整個*集合*，用來整合和排序。
不幸的是，音頻API獨立處理每一個`playSound()`調用。
看起來這些請求像是從針眼穿過一樣，一次只能有一個。

* **問題二：請求無法合併處理。**

這個問題與下面的問題相比只是小煩惱。
現在，我們在很多不同的遊戲系統中散佈了`playSound()`調用。
但是遊戲引擎是在現代多核機器上運行的。
爲了使用多核帶來的優勢，我們將系統分散在不同線程上——渲染在一個，AI在另一個，諸如此類。

由於我們的API是同步的，它在*調用者*的線程上運行。
當從不同的遊戲系統調用時，我們從多個線程同時使用API。
看看示例代碼，看到任何線程同步性嗎？我也沒看到。

當我們想要分配一個*單獨的*線程給音頻，這個問題就更加嚴重。
當其他線程都忙於互相跟隨和製造事物，它只是傻傻待在那裏。

* **問題三：請求在錯誤的線程上執行。**

音頻引擎調用`playSound()`意味着，“放下任何東西，現在就播放聲音！”*立即*就是問題。
遊戲系統在*它們*方便時調用`playSound()`，但是音頻引擎不一定能方便去處理這個請求。
爲了解決這點，我們需要將*接受*請求和*處理*請求解耦。

## 模式

**事件隊列**在隊列中按先入先出的順序存儲一系列**通知或請求**。
發送通知時，**將請求放入隊列並返回**。
處理請求的系統之後稍晚**從隊列中獲取請求**並處理。
這**解耦了發送者和接收者**，既**靜態**又**及時**。

## 何時使用

<span name="simple"></span>

如果你只是想解耦*接收者*和發送者，像<a href="observer.html">觀察者模式</a>
和<a href="command.html">命令模式</a>都可以用較小的複雜度進行處理。
在解耦某些需要*及時*處理的東西時使用隊列。

<aside name="simple">

我在之前的幾乎每章都提到了，但這值得反覆提。
複雜度會拖慢你，所以要將簡單視爲珍貴的財寶。

</aside>

用推和拉來考慮。
有一塊代碼A需要另一塊代碼B去做些事情。
對A自然的處理方式是將請求*推*給B。

同時，對B自然的處理方式是在*B*方便時將請求*拉*入。
當一端有推模型另一端有拉模型，你需要在它們之間設置緩存。
這就是隊列比簡單的解耦模式多提供的部分。

隊列給了代碼對拉取的控制權——接收者可以延遲處理，合併或者忽視請求。
但隊列做這些事是通過將控制權從發送者那裏*拿走*完成的。
發送者能做的就是向隊列發送請求然後祈禱。
當發送者需要回復時，隊列不是好的選擇。

## 記住

不像本書中的其他模式，事件隊列很複雜，會對遊戲架構產生廣泛影響。
這就意味着你得仔細考慮如何——或者要不要——使用它。

### 中心事件隊列是一個全局變量

這個模式的常用方法是一個大的交換站，遊戲中的每個部分都能將消息送到這裏。
這是很有用的基礎架構，但是*有用*並不代表*好用*。

可能要走一些彎路，但是我們中的大多數最終學到了全局變量是不好的。
當有一小片狀態，程序的每部分都能接觸到，會產生各種微妙的相關性。
這個模式將狀態封裝在協議中，但是它還是全局的，仍然有全局變量引發的全部危險。

### 世界的狀態可以因你改變

假設在虛擬的小怪結束它一生時，一些AI代碼將“實體死亡”事件發送到隊列中。
這個事件在隊列中等待了誰知有多少幀後才排到了前面，得以處理。

同時，經驗系統想要追蹤英雄的殺敵數，並對他的效率加以獎勵。
它接受每個“實體死亡”事件，然後決定英雄擊殺了何種怪物，以及擊殺的難易程度，最終計算出合適的獎勵。

這需要遊戲世界的多種不同狀態。
我們需要死亡的實體以獲取擊殺它的難度。
我們也許要看看英雄的周圍有什麼其他的障礙物或者怪物。
但是如果事件沒有及時處理，這些東西都會消失。
實體可能被清除，周圍的東西也有可能移開。

當你接到事件時，得小心，不能假設*現在的*狀態反映了*事件發生時*的世界。
這就意味着隊列中的事件比同步系統中的事件需要存儲更多數據。
在後者中，通知只需說“某事發生了”然後接收者可以找到細節。
使用隊列時，這些短暫的細節必須在事件發送時就被捕獲，以方便之後使用。

### 會陷於反饋系統環路中

任何事件系統和消息系統都得擔心環路：

1. A發送了一個事件
2. B接收然後發送事件作爲迴應。
3. 這個事件恰好是A關注的，所以它收到了。爲了迴應，它發送了一個事件。
4. 回到2.

<span name="log"></span>

當消息系統是*同步的*，你很快就能找到環路——它們造成了棧溢出並讓遊戲崩潰。
使用隊列，它會異步地使用棧，即使虛假事件晃來晃去，遊戲仍然可以繼續運行。
避免這個的通用方法就是避免在*處理*事件的代碼中*發送*事件。

<aside name="log">

在你的事件系統中加一個小小的漏洞日誌也是一個好主意。

</aside>

## 示例代碼

我們已經看到一些代碼了。它不完美，但是有基本的正確功能——公用的API和正確的底層音頻調用。
剩下需要做的就是修復它的問題。

第一個問題是我們的API是*阻塞的*。
當代碼播放聲音時，它不能做任何其他事情，直到`playSound()`加載完音頻然後真正地開始播放。

我們想要推遲這項工作，這樣 `playSound()` 可以很快地返回。
爲了達到這一點，我們需要*具體化*播放聲音的請求。
我們需要一個小結構存儲發送請求時的細節，這樣我們晚些時候可以使用：

^code play-message

下面我們需要給`Audio`一些存儲空間來追蹤正在播放的聲音。
現在，你的算法專家也許會告訴你使用激動人心的數據結構，
比如[Fibonacci heap](http://en.wikipedia.org/wiki/Fibonacci_heap)或者[skip list](http://en.wikipedia.org/wiki/Skip_list)或者最起碼*鏈表*。
但是在實踐中，存儲一堆同類事物最好的辦法是使用一個平凡無奇的經典數組：

<aside name="prof">

算法研究者通過發表對新奇數據結構的研究獲得收入。
他們不鼓勵使用基本的結構。

</aside>

* 沒有動態分配。

* 沒有爲記錄信息造成的額外的開銷或者多餘的指針。

<span name="locality"></span>

* 對緩存友好的連續存儲空間。

<aside name="locality">

更多“緩存友好”的內容，見<a href="data-locality.html" class="pattern">數據局部性</a>一章。

</aside>

所以讓我們開幹吧：

^code pending-array

我們可以將數組大小設置爲最糟情況下的大小。
爲了播放聲音，簡單地將新消息插到最後：

^code array-play

這讓`playSound()`幾乎是立即返回，當然我們仍得播放聲音。
那塊代碼在某處，即`update()`方法中：

<span name="update"></span>

^code array-update

<aside name="update">

就像名字暗示的，這是<a href="update-method.html" class="pattern">更新方法</a>模式。

</aside>

現在我們需要在方便時候調用。
這個“方便”取決於你的遊戲。
它也許要從主<a href="game-loop.html" class="pattern">遊戲循環</a>中或者專注於音頻的線程中調用。

這可行，但是這假定了我們在對`update()`的單一調用中可以處理*每個*聲音請求。
如果你做了像在聲音資源加載後處理異步請求的事情，這就沒法工作了。
`update()`一次處理一個請求，它需要有完成一個請求後從緩存中再拉取一個請求的能力。
換言之，我們需要一個真實的隊列。

### 環狀緩存

有很多種方式能實現隊列，但我最喜歡的是*環狀緩存*。
它保留了數組的所有優點，同時能讓我們不斷從隊列的前方移除事物。

現在，我知道你在想什麼。
如果我們從數組的前方移除東西，不是需要將所有剩下的部分都移動一次嗎？這不是很慢嗎？

這就是爲什麼要學習鏈表——你可以從中移除一個節點，而無需移動東西。
好吧，其實你可以用數組實現一個隊列而無需移動東西。
我會展示給你看，但是首先預習一些術語：

*  隊列的**頭部**是*讀取*請求的地方。頭部存儲最早發出的請求。

*  **尾部**是另一端。它是數組中下個*寫入*請求的地方。注意它指向隊列終點的下一個位置。你可以將其理解爲一個半開半閉區間，如果這有幫助的話。

由於 `playSound()` 向數組的末尾添加了新的請求，頭部開始指向元素0而尾部向右增長。

<img src="images/event-queue-queue.png" alt="一數組事件。頭部指向第一個元素，尾部向右增長。" />

讓我們開始編碼。首先，我們顯式定義這兩個標記在類中的意義：

^code head-tail

在 `playSound()` 的實現中，`numPending_`被`tail_`取代，但是其他都是一樣的：

^code tail-play

更有趣的變化在`update()`中：

^code tail-update

我們在頭部處理，然後通過將頭部指針向右移動來消除它。
我們定義頭尾之間沒有距離的隊列爲<span name="empty">空隊列</span>。

<aside name="empty">

這就是爲什麼我們讓尾部指向最後元素*之後*的那個位置。
這意味着頭尾相等則隊列爲空。

</aside>

<span name="party"></span>

現在，我們獲得了一個隊列——我們可以向尾部添加元素，從頭部移除元素。
這裏有很明顯的問題。在我們讓隊列跑起來後，頭部和尾部繼續向右移動。
最終`tail_`碰到了數組的尾部，歡樂時光結束了。
接下來是這個方法的靈巧之處。

<aside name="party">

你想結束歡樂時光嗎？不，你不想。

</aside>

<img src="images/event-queue-crawl.png" alt="像之前一樣的數組，但是現在頭部在向右移動，在左側留下空白格子。" />

注意當尾部移動時，*頭部* 也是如此。
這就意味着在數組*開始*部分的元素不再被使用了。
所以我們做的就是，當抵達末尾時，將尾部折回到數組的頭部。
這就是爲什麼它被稱爲*環狀*緩存，它表現得像是一個環狀的數組。

<img src="images/event-queue-ring.png" alt="數組繞了一圈，現在頭部可以回到開始時指向的地方了。" />

這個的實現非常簡單。
當我們入隊一個事物時，只需要保證尾部在抵達末尾的時候折回到數組的開頭：

^code ring-play

替代`tail++`，將增量設爲數組長度的模，這樣可將尾部回折回來。
另一個改變是斷言。我們得保證隊列不會溢出。
只要這裏有少於`MAX_PENDING`的請求在隊列中，在頭部和尾部之間就有沒有使用的間隔。
如果隊列滿了，那就不會有間隔了，就像古怪的銜尾蛇一樣，尾部會遇到頭部然後覆蓋它。
斷言保證了這不會發生。

在`update()`中，頭部也折回了：

^code ring-update

<span name="capacity"></span>

這樣就好——沒有動態分配，沒有數據拷貝，緩存友好的簡單數組實現的隊列完成了。

<aside name="capacity">

如果最大容量影響了你，你可以使用增長的數組。
當隊列滿了後，分配一塊當前數組兩倍大的數組（或者更多倍），然後將對象拷進去。

哪怕你在隊列增長時拷貝，入隊仍然有常數級的*攤銷*複雜度。

</aside>

### 合併請求

現在有隊列了，我們可以轉向其他問題了。
首先來解決多重請求播放同一音頻，最終導致音量過大的問題。
由於我們知道哪些請求在等待處理，需要做的所有事就是將請求和早先等待處理的請求合併：

^code drop-dupe-play

當有兩個請求播放同一音頻時，我們將它們合併成只保留聲音最大的請求。
這一“合併”非常簡陋，但是我們可以用同樣的方法做很多有趣的合併。

注意在請求*入隊*時合併，而不是*處理*時。
在隊列中處理更加容易，因爲不需要在最終會被合併的多餘請求上浪費時間。
這也更加容易被實現。

<span name="slow"></span>

但是，這確實將處理的職責放在了調用者肩上。
對`playSound()`的調用返回前會遍歷整個隊列。
如果隊列很長，那麼會很慢。
在`update()`中合併也許更加合理。

<aside name="slow">

避免*O(n)* 的隊列掃描代價的另一種方式是使用不同的數據結構。
如果我們將`SoundId`作爲哈希表的鍵，那麼我們就可以在常量時間內檢查重複。

</aside>

這裏有些要記住的要點。
我們能夠合併的“同步”請求窗口只有隊列長度那麼大。
如果我們快速處理請求，隊列長度就會保持較短，我們就有更少的機會合並東西。
同樣地，如果處理慢了，隊列滿了，我們能找到更多的東西合併。

這個模式隔離了請求者和請求何時被處理，但如果你將整個隊列交互視爲與數組結構交互，
那麼發出請求和處理它之間的延遲會顯式地影響行爲。
確認在這麼做之前保證了這不會造成問題。

### 分離線程

最終，最險惡的問題。
使用同步的音頻API，調用`playSound()`的線程就是處理請求的線程。
這通常不是我們想要的。

<span name="multicore"></span>

在今日的多核硬件上，你需要不止一個線程來最大程度使用芯片。
有無數的編程範式在線程間分散代碼，但是最通用的策略是將每個獨立的領域分散到一個線程——音頻，渲染，AI等等。

<aside name="multicore">

單線程代碼同時只在一個核心上運行。
如果你不使用線程，哪怕做了流行的異步風格編程，能做的極限就是讓一個核心繁忙，那也只發揮了CPU能力的一小部分。

服務器程序員將他們的程序分割成多個獨立*進程*作爲彌補。
這讓系統在不同的核上同時運行它們。
遊戲幾乎總是單進程的，所以增加線程真的有用。

</aside>

我們很容易就能做到這一點是因爲三個關鍵點：

1. 請求音頻的代碼與播放音頻的代碼解耦。
2. 有隊列在兩者之間整理它們。
3. 隊列與程序其他部分是隔離的。

剩下要做的事情就是寫修改隊列的方法——`playSound()`和`update()`——使之線程安全。
通常，我會寫一寫具體代碼完成之，但是由於這是一本關於架構的書，我不想着眼於一些特定的API或者鎖機制。

從高層看來，我們只需保證隊列不是同時被修改的。
由於`playSound()`只做了一點點事情——基本上就是聲明字段——不會阻塞線程太長時間。
在`update()`中，我們等待條件變量之類的東西，直到有請求需要處理時纔會消耗CPU循環。

## 設計決策

很多遊戲使用事件隊列作爲交流結構的關鍵部分，你可以花很多時間設計各種複雜的路徑和消息過濾器。
但是在構建洛杉磯電話交換機之類的東西之前，我推薦你從簡單的開始。這裏是幾個需要在開始時思考的問題：

### 隊列中存儲了什麼？

到目前爲止，我交替使用“事件”和“消息”，因爲大多時候兩者的區別並不重要。
無論你在隊列中塞了什麼都可以獲得解耦和合並的能力，但是還是有幾個地方不同。

* **如果你存儲事件：**

    “事件”或者“通知”描繪*已經*發生的事情，比如“怪物死了”。
    你入隊它，這樣其他對象可以對這個事件作出*迴應*，有點像異步的<a href="observer.html" class="gof-pattern">觀察者</a>模式。

    * *很可能允許多個監聽者。*
      由於隊列包含的是已經發生的事情，發送者可能不關心誰接受它。
      從這個層面來說，事件發生在過去，早已被遺忘。

    * *訪問隊列的模塊更廣。*
      事件隊列通常*廣播*事件到任何感興趣的部分。爲了儘可能允許所有感興趣的部分訪問，隊列一般是全局可見的。

* **如果你存儲消息：**

    <span name="command"></span>

    “消息”或“請求”描繪了*想要*發生*在未來*的事情，比如“播放聲音”。可以將其視爲服務的異步API。

    <aside name="command">

    另一個描述“請求”的詞是“命令”，就像在<a href="command.html" class="gof-pattern">命令模式</a>中那樣，隊列也可以在那裏使用。

    </aside>

    <span name="locator"></span>

     * *更可能只有一個監聽者。*
        在這個例子中，存儲的消息只請求*音頻API*播放聲音。如果引擎的隨便什麼部分都能從隊列中拿走消息，那可不好。

        <aside name="locator">

        我在這裏說“更可能”，因爲只要像期望的*那樣*處理消息，消息入隊時可以不必擔心哪塊代碼處理它。
        這樣的話，你在做的事情類似於<a href="service-locator.html" class="pattern">服務定位器</a>。

        </aside>

### 誰能從隊列中讀取？

在例子中，隊列是密封的，只有`Audio`類可以從中讀取。
在用戶交互的事件系統中，你可以在覈心內容中註冊監聽器。
有時可以聽到術語“單播”和“廣播”來描述它，兩者都很有用。

* **單播隊列：**

    在隊列是類API的一部分時，單播是很自然的。
    就像我們的音頻例子，從調用者的角度來說，它們只能看到可以調用的`playSound()`方法。

    * *隊列變成了讀取者的實現細節。* 發送者知道的所有事就是發條消息。

    * *隊列更封裝。* 其他都一樣時，越多封裝越方便。

    * *無須擔心監聽者之間的競爭。*
      使用多個監聽者，你需要決定隊列中的每個事物*一對多*分給全部的監聽者（廣播）
      還是隊列中的*每個*事物*一對一*分給單獨的監聽者（更加像工作隊列）。

        在兩種情況下，監聽者最終要麼做了多餘的事情要麼在相互干擾，你得謹慎考慮想要的行爲。
        使用單一的監聽者，這種複雜性消失了。

* **廣播隊列：**

    這是大多數“事件”系統工作的方法。如果你有十個監聽者，一個事件進來，所有監聽者都能看到這個事件。

    *  *事件可能無人接收。*
      前面那點的必然推論就是如果有*零個*監聽者，沒有誰能看到這個事件。
      在大多數廣播系統中，如果處理事件時沒有監聽者，事件就消失了。

    * *也許需要過濾事件。*
      廣播隊列經常對程序的所有部分可見，最終你會獲得一系列監聽者。
      很多事件乘以很多監聽者，你會獲取一大堆事件處理器。

        爲了削減大小，大多數廣播事件系統讓監聽者篩出其需要接受的事件。
        比如，可能它們只想要接受鼠標事件或者在某一UI區域內的事件。

* **工作隊列：**

    類似廣播隊列，有多個監聽器。不同之處在於隊列中的每個東西只會投到監聽器*其中的一個*。
    常應用於將工作打包給同時運行的線程池。

    * *你得規劃。*
      由於一個事物只有一個監聽器，隊列邏輯需要指出最好的選項。
      這也許像round robin算法或者亂序選擇一樣簡單，或者可以使用更加複雜的優先度系統。

### 誰能寫入隊列？

<span name="configs"></span>

這是前一個設計決策的另一面。
這個模式兼容所有可能的讀/寫設置：一對一，一對多，多對一，多對多。

<aside name="configs">

你有時聽到用“扇入”描述多對一的溝通系統，而用“扇出”描述一對多的溝通系統。

</aside>

* **使用單個寫入器：**

    這種風格和同步的<a href="observer.html" class="gof-pattern">觀察者</a>模式很像。
    有特定對象收集所有可接受的事件。

    * *你隱式知道事件是從哪裏來的。*
      由於這裏只有一個對象可向隊列添加事件，任何監聽器都可以安全地假設那就是發送者。

    * *通常允許多個讀取者。*
      你可以使用單發送者對單接收者的隊列，但是這樣溝通系統更像純粹的隊列數據結構。

* **使用多個寫入器：**

    這是例子中音頻引擎工作的方式。
    由於`playSound()`是公開的方法，代碼庫的任何部分都能給隊列添加請求。“全局”或“中心”事件總線像這樣工作。

    * *得更小心環路。*
      由於任何東西都有可能向隊列中添加東西，這更容易意外地在處理事件時添加事件。
      如果你不小心，那可能會觸發反饋循環。

     * *很可能需要在事件中添加對發送者的引用。*
        當監聽者接到事件時，它不知道是誰發送的，因爲可能是任何人。
         如果它確實需要知道發送者，你得將發送者打包到事件對象中去，這樣監聽者纔可以使用它。

### 對象在隊列中的生命週期如何？

使用同步的通知，當所有的接收者完成了消息處理纔會返回發送者。
這意味着消息本身可以安全地存在棧的局部變量中。
使用隊列，消息比讓它入隊的調用活得更久。

如果你使用有垃圾回收的語言，你無需過度擔心這個。
消息存到隊列中，會在需要它的時候一直存在。
而在C或C++中，得由你來保證對象活得足夠長。

* **傳遞所有權：**

    這是手動管理內存的傳統方法。當消息入隊時，隊列擁有了它，發送者不再擁有它。
    當它被處理時，接收者獲取了所有權，負責銷燬他。

    <aside name="unique">

    在C++中，`unique_ptr<T>`給了你同樣的語義。

    </aside>

* **共享所有權：**

    現在，甚至C++程序員都更適應垃圾回收了，分享所有權更加可接受。
    這樣，消息只要有東西對其有引用就會存在，當被遺忘時自動釋放。

    <aside name="shared">

    同樣的，C++的風格是使用`shared_ptr<T>`。

    </aside>

* **隊列擁有它：**

    <span name="pool"></span>

    另一個選項是讓消息*永遠*存在於隊列中。
    發送者不再自己分配消息的內存，它向內存請求一個“新的”消息。
    隊列返回一個隊列中已經在內存的消息的引用，接收者引用隊列中相同的消息。

    <aside name="pool">

    換言之，隊列存儲的背後是一個<a href="object-pool.html" class="pattern">對象池</a>模式。

    </aside>

## 參見

* 我在之前提到了幾次，很大程度上，
  這個模式是廣爲人知的<a href="observer.html" class="gof-pattern">觀察者</a>模式的異步實現。

* 就像其他很多模式一樣，事件隊列有很多別名。
  其中一個是“消息隊列”。這通常指代一個更高層次的實現。
  事件隊列在應用*中*，消息隊列通常在應用*間*交流。

    另一個術語是“發佈/提交”，有時被縮寫爲“pubsub”。
    就像“消息隊列”一樣，這通常指代更大的分佈式系統，而不是現在關注的這個模式。

* [確定狀態機](http://en.wikipedia.org/wiki/Finite-state_machine)，很像GoF的<a href="state.html" class="gof-pattern">狀態模式</a>，需要一個輸入流。如果想要異步響應，可以考慮用隊列存儲它們。

    當你有一對狀態機相互發送消息時，每個狀態機都有一個小小的未處理隊列（被稱爲一個*信箱*），
    然後你需要重新發明[actor model](http://en.wikipedia.org/wiki/Actor_model)。

* [Go](http://golang.org/)語言內建的“通道”類型本質上是事件隊列或消息隊列。
