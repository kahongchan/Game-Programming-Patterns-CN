^title 類型對象 Type Object
^section Behavioral Patterns

## 意圖

*創造一個類A來允許靈活地創造新“類型”，類A的每個實例都代表了不同的對象類型。*

## 動機

想象我們在製作一個奇幻RPG遊戲。
我們的任務是爲一羣想要殺死英雄的惡毒怪物編寫代碼。
怪物有多個的屬性：生命值，攻擊力，圖形效果，聲音表現，等等。
但是爲了說明介紹的目的我們先只考慮前面兩個。

遊戲中的每個怪物都有當前血值。
開始時是滿的，每次怪物受傷，它就下降。
怪物也有一個攻擊字符串。
當怪物攻擊我們的英雄，那個文本就會以某種方式展示給用戶。
（我們不在乎這裏怎樣實現。）

設計者告訴我們怪物有不同*品種*，像“龍”或者“巨魔”。
每個品種都描述了一*種*存在於遊戲中的怪物，同時可能有多個同種怪物在地牢裏遊蕩。

品種決定了怪物的初始健康——龍開始的血量比巨魔多，它們更難被殺死。
這也決定了攻擊字符——同種的所有怪物都以相同的方式進行攻擊。

### 傳統的面向對象方案

<span name="isa"></span>

想着這樣的設計方案，我們啓動了文本編輯器開始編程。
根據設計，龍是一種怪物，巨魔是另一種，其他品種的也一樣。
用面向對象的方式思考，這引導我們創建`Monster`基類。

<aside name="isa">

這是一種“是某物”的關係。
在傳統OOP思路中，由於龍“是”怪物，我們用`Dragon`是`Monster`的子類來描述這點。
如我們將看到的，繼承是一種將這種關係表示爲代碼的方法。

</aside>

^code 1

在怪物攻擊英雄時，公開的`getAttack()`函數讓戰鬥代碼能獲得需要顯示的文字。
每個子類都需要重載它來提供不同的消息。

構造器是protected的，需要傳入怪物的初始血量。
每個品種的子類的公共構造器調用這個構造器，傳入對於該品種適合的起始血量。

現在讓我們看看兩個品種子類：

<span name="exclaim"></span>

^code 2

<aside name="exclaim">

感嘆號讓所有事情都更刺激！

</aside>

每個從`Monster`派生出來的類都傳入起始血量，重載`getAttack()`返回那個品種的攻擊字符串。
所有事情都一如所料地運行，不久以後，我們的英雄就可以跑來跑去殺死各種野獸了。
我們繼續編程，在意識到之前，我們就有了從酸泥怪到殭屍羊的衆多怪物子類。

然後，很奇怪，事情陷入了困境。
設計者最終想要*幾百個*品種，但是我們發現所有的時間都花費在寫這些只有七行長的子類和重新編譯上。
這會繼續變糟——設計者想要協調已經編碼的品種。我們之前富有產出的工作日退化成了：

1. 收到設計者將巨魔的血量從48改到52的郵件。
2. 簽出並修改`Troll.h`。
3. 重新編譯遊戲。
4. 簽入修改。
5. 回覆郵件。
6. 重複。

我們度過了失意的一天，因爲我們變成了填數據的猴子。
設計者也感到挫敗，因爲修改一個數據就要老久。
我們需要的是一種無需每次重新編譯遊戲就能修改品種的狀態。
如果設計者創建和修改品種時無需*任何*程序員的介入那就更好了。

### 爲類型建類

從較高的層次看來，我們試圖解決的問題非常簡單。
遊戲中有很多不同的怪物，我們想要在它們之間分享屬性。
一大羣怪物在攻擊英雄，我們想要它們中的一些使用相同的攻擊文本。
我們聲明這些怪物是相同的“品種”，而品種決定了攻擊字符串。

這種情況下我們很容易想到類，那就試試吧。
龍是怪物，每條龍都是龍“類”的實例。
定義每個品種爲抽象基類`Monster` 的子類，讓遊戲中每個怪物都是子類的實例反映了那點。最終的類層次是這樣的：

<span name="inherits-arrow"></span>

<img src="images/type-object-subclasses.png" alt="一個怪物類，派生出龍、巨魔這樣的子類。" />

<aside name="inherits-arrow">

這裏的<img src="images/arrow-inherits.png" class="arrow" alt="一個代表繼承的UML箭頭。" />意爲“從……繼承”。

</aside>

每個怪物的實例屬於某個繼承怪物類的類型。
我們有的品種越多，類層次越高。
這當然是問題：添加新品種就需要添加新代碼，而每個品種都需要被編譯爲它自己的類型。

這可行，但不是唯一的選項。
我們也可以重構代碼讓每個怪物*有*品種。
不是讓每個品種繼承`Monster`，我們現在有單一的`Monster`類和`Breed`類。

<span name="references-arrow"></span>

<img src="images/type-object-breed.png" alt="一個怪物類，有一個指向Breed類的引用。" />

<aside name="references-arrow">

這裏<img src="images/arrow-references.png" class="arrow" alt="一個代表引用的UML箭頭。" />意爲“被……引用”。

</aside>

這就成了，就兩個類。注意這裏完全沒有繼承。
通過這個系統，遊戲中的每個怪物都是`Monster`的實例。
`Breed`類包含了在不同品種怪物間分享的信息：開始血量和攻擊字符串。

爲了將怪物與品種相關聯，我們給了每個`Monster`實例對包含品種信息的`Breed`對象的引用。
爲了獲得攻擊字符串，一個怪獸可以調用它品種的方法。
`Breed`類本質上定義了一個怪物的*類型*，這就是爲啥這個模式叫做類型對象。

這個模式特別有用的一點是，我們現在可以定義全新的*類型*而無需攪亂代碼庫。
我們本質上將部分的類型系統從硬編碼的繼承結構中拉出，放到可以在運行時定義的數據中去。

我們可以通過用不同值實例化`Monster`來創建成百上千的新品種。
如果從配置文件讀取不同的數據初始化品種，我們就有能力完全靠數據定義新怪物品種。
這麼容易，設計者也可以做到！

## 模式

定義**類型對象**類和**有類型的對象**類。每個類型對象實例代表一種不同的邏輯類型。
每種有類型的對象保存**對描述它類型的類型對象的引用**。

實例相關的數據被存儲在有類型對象的實例中，被同種類分享的數據或者行爲存儲在類型對象中。
引用同一類型對象的對象將會像同一類型一樣運作。
這讓我們在一組相同的對象間分享行爲和數據，就像子類讓我們做的那樣，但沒有固定的硬編碼子類集合。

## 何時使用

在任何你需要定義不同“種”事物，但是語言自身的類型系統過於僵硬的時候使用該模式。尤其是下面兩者之一成立時：

* 你不知道你後面還需要什麼類型。（舉個例子，如果你的遊戲需要支持資料包，而資料包有新的怪物品種呢？）

* 想不改變代碼或者重新編譯就能修改或添加新類型。

## 記住

這個模型是關於將“類型”的定義從命令式僵硬的語言世界移到靈活但是缺少行爲的對象內存世界。
靈活性很好，但是將類型提到數據喪失了一些東西。

### 需要手動追蹤類型對象

<span name="vtable"></span>

使用像C++類型系統這種東西的好處之一就是編譯器自動記錄類的註冊。
定義類的數據自動編譯到可執行的靜態內存段然後就運作起來了。

使用類型對象模式，我們現在不但要負責管理內存中的怪物，同時要管理它們的*類型*
——我們要保證，只要我的怪物需要，所有的品種對象都能實例化並保存在內存中。
無論何時創建新的怪物，由我們來保證能初始化爲含有品種的引用。

我們從編譯器的限制中解放了自己，但是代價是需要重新實現一些它以前爲我們做的事情。

<aside name="vtable">

C++內部使用了“虛函數表”（“vtable”）實現虛方法。
虛函數表是個簡單的`struct`，包含了一集合函數指針，每個對應一個類中的虛方法。
在內存中每個類有一個虛函數表。每個類的實例有一個指針指向它的類的虛函數表。

當你調用一個虛函數，代碼首先在虛函數表中查找對象，然後調用表中函數指針指向的函數。

聽起來很熟悉？虛函數表就是個品種對象，而指向虛函數表的指針是怪物保留的、指向品種的引用。
C++的類是C中的類型對象，由編譯器自動處理。

</aside>

### 更難爲每種類型定義*行爲*

使用子類派生，你可以重載方法，然後做你想做的事——用程序計算值，調用其他代碼，等等。
天高任鳥飛。如果我們想的話，可以定義一個怪物子類，根據月亮的階段改變它的攻擊字符串。（我覺得就像狼人。）

當我們使用類型對象模式時，我們將重載的方法替換成了成員變量。
不再讓怪物的子類重載方法，用不同的*代碼*來*計算*攻擊字符串，而是讓我們的品種對象在不同的*變量*中*存儲*攻擊字符串。

這讓使用類型對象定義類型相關的*數據*變得容易，但是定義類型相關的*行爲*變得困難。
如果，舉個例子，不同品種的怪物需要使用不同的AI算法，使用這個模式就面臨着挑戰。

<span name="fn"></span>

有很多方式可以讓我們跨越這個限制。
一個簡單的方式是使用預先定義的固定行爲，
然後類型對象中的數據簡單地*選擇*它們中的一個。
舉例，假設我們的怪物AI總是處於“站着不動”、“追逐英雄”或者“恐懼地嗚咽顫抖”（嘿，他們不可能都是強勢的龍）狀態。
我們可以定義函數來實現每種行爲。
然後，我們在方法中存儲合適函數的引用，將AI算法與品種相關聯。

<aside name="fn">

聽起來很熟悉？這是在*我們的*類型對象中實現虛函數表。

</aside>

<span name="data"></span>

另一個更加徹底的解決方案是真正地在數據中支持定義行爲。
<a class="gof-pattern" href="http://c2.com/cgi-bin/wiki?InterpreterPattern">解釋器</a>模式和<a class="pattern" href="bytecode.html">字節碼</a>模式讓我們定義有行爲的對象。
如果我們讀取數據文件並用上面兩種模式之一構建數據結構，我們就將行爲完全從代碼中移出，放入了數據之中。

<aside name="data">

時過境遷，遊戲越來越多地由數據驅動。
硬件變得更爲強大，我們發現比起能榨乾多少硬件的性能，瓶頸更多於在能完成多少內容。
使用64K軟盤的時代，挑戰是將遊戲*塞入*其中。
而在使用雙面DVD的時代，挑戰是用遊戲*填滿*它。

腳本語言和其他定義遊戲行爲的高層方式能給我們提供必要的生產力，同時只消耗可預期的運行時性能。
由於硬件越來越好，而大腦並非如此，這種交換越來越有意義。

</aside>

## 示例代碼

在第一遍實現中，讓我們從簡單的開始，只構建動機那節提到的基礎系統。
我們從`Breed`類開始：

^code 3

很簡單。它基本上只是兩個數據字段的容器：起始血量和攻擊字符串。
讓我們看看怪物怎麼使用它：

^code 4

當我們建構怪物時，我們給它一個品種對象的引用。
它定義了怪物的品種，取代了之前的子類。
在構造函數中，`Monster`使用的品種決定了起始血量。
爲了獲得攻擊字符串，怪物簡單地將調用轉發給它的品種。

這段非常簡單的代碼是這章的核心思路。剩下的任何東西都是紅利。

### 讓類型對象更像類型：構造器

現在，我們可以直接構造怪物並負責傳入它的品種。
和常用的OOP語言實現的對象相比這有些退步——我們通常不會分配一塊空白內存，然後*賦予*它類型。
相反，我們根據類調用構造器，它負責創建一個新實例。

<span name="pattern"></span>

我們可以在類型對象上應用同樣的模式。

^code 5

<aside name="pattern">

“模式”一詞用在這裏正合適。我們討論的是設計模式中經典的模式：<a class="gof-pattern" href="http://c2.com/cgi/wiki?FactoryMethodPattern">工廠方法</a>。

在一些語言中，這個模式被用來構造*所有*的對象。
在Ruby，Smalltalk，Objective-C以及其他類是對象的語言中，你通過在類對象本身上調用方法來構建實例。

</aside>

以及那個使用它們的類：

^code 6

<span name="friend"></span>

不同的關鍵點在於`Breed`中的`newMonster()`。
這是我們的“構造器”工廠方法。使用我們原先的實現，就像這樣創建怪物：

<aside name="friend">

這裏還有一個小小的不同。
因爲樣例代碼由C++寫就，我們可以使用一個小小的特性：*友類*。

我們讓`Monster`的構造器成爲私有，防止了任何人直接調用它。
友類放鬆了這個限制，`Breed`仍可接觸它。
這意味着構造怪物的*唯一*方法是通過`newMonster()`。

</aside>

^code 7

在我們改動後，它看上去是這樣：

^code 8

所以，爲什麼這麼做？創建一個對象分爲兩步：內存分配和初始化。
`Monster`的構造器讓我們做完了所有需要的初始化。
在例子中，那隻存儲了類型；但是在完整的遊戲中，那需要加載圖形，初始化怪物AI以及做其他的設置工作。

但是，那都發生在內存分配*之後*。
在構造器調用前，我們已經找到了內存放置怪物。
在遊戲中，我們通常也想控制對象創造這一環節：
我們通常使用自定義的分配器或者<a class="pattern" href="object-pool.html">對象池</a>模式來控制對象最終在內存中的位置。

在`Breed`中定義“構造器”函數給了我們地方實現這些邏輯。
不是簡單地調用`new`,`newMonster()`函數可以在將控制權傳遞給`Monster`初始化之前，從池中或堆中獲取內存。
通過在*唯一*有能力創建怪物的`Breed`函數中放置這些邏輯，
我們保證了所有怪物變量遵守了內存管理規範。

### 通過繼承分享數據

我們現在已經實現了能完美服務的類型對象系統，但是它非常基礎。
我們的遊戲最終有*上百*種不同品種，每種都有成打的特性。
如果設計者想要協調30種不同的巨魔，讓它們變得強壯一點，他會得處理很多數據。

能幫上忙的是在不同*品種*間分享屬性的能力，一如品種在不同的*怪物*間分享屬性的能力。
就像我們在之前OOP方案中做的那樣，我們可以使用派生完成這點。
只是，這次，不使用語言的繼承機制，我們用類型對象實現它。

簡單起見，我們只支持單繼承。
就像類可以有一個父類，我們允許品種有一個父品種：

^code 9

當我們構建一個品種，我們先傳入它繼承的父品種。
我們可以爲基礎品種傳入`NULL`表明它沒有祖先。

爲了讓這有用，子品種需要控制它從父品種繼承了哪些屬性，以及哪些屬性需要重載並由自己指定。
在我們的示例系統中，我們可以說品種用非零值重載了怪物的健康，用非空字符串重載了攻擊字符串。
否則，這些屬性要從它的父品種裏繼承。

實現方式有兩種。
一種是每次屬性被請求時動態處理委託，就像這樣：

^code 10

如果品種在運行時修改種類，不再重載，或者不再繼承某些屬性時，這能保證做正確的事。
另一方面，這要更多的內存（它需要保存指向它的父品種的指針）而且更慢。
每次你查找屬性都需要回溯繼承鏈。

如果我們可以保證品種的屬性不變，一個更快的解決方案是在*構造時*使用繼承。
這被稱爲“複製”委託，因爲在創建對象時，我們*複製*繼承的屬性*到*推導的類型。它看上去是這樣的：

^code copy-down

注意現在我們不再需要給父品種的字段了。
一旦構造器完成，我們可以忘了父品種，因爲我們已經拷貝了它的所有屬性。
爲了獲得品種的屬性，我們現在直接返回字段：

^code copy-down-access

又好又快！

假設遊戲引擎從品種的JSON文件加載設置然後創建類型。它看上去是這樣的：

    :::json
    {
      "Troll": {
        "health": 25,
        "attack": "The troll hits you!"
      },
      "Troll Archer": {
        "parent": "Troll",
        "health": 0,
        "attack": "The troll archer fires an arrow!"
      },
      "Troll Wizard": {
        "parent": "Troll",
        "health": 0,
        "attack": "The troll wizard casts a spell on you!"
      }
    }
    
    :::json
    {
      "Troll": {
        "health": 25,
        "attack": "The troll hits you!"
      },
      "Troll Archer": {
        "parent": "Troll",
        "health": 0,
        "attack": "The troll archer fires an arrow!"
      },
      "Troll Wizard": {
        "parent": "Troll",
        "health": 0,
        "attack": "The troll wizard casts a spell on you!"
      }
    }

我們有一段代碼讀取每個品種，用新數據實例化品種實例。
就像你從`"parent": "Troll"`字段看到的， `Troll Archer`和`Troll Wizard`品種都由基礎`Troll`品種繼承而來。

由於派生類的初始血量都是0，所以該值從基礎`Troll`品種繼承。
這意味着無論怎麼調整`Troll`的血量，三個品種的血量都會被更新。
隨着品種的數量和屬性的數量增加，這節約了很多時間。
現在，通過一小塊代碼，系統給了設計者控制權，讓他們能好好利用時間。
與此同時，我們可以回去編碼其他特性了。

## 設計決策

類型對象模式讓我們建立類型系統，就好像在設計自己的編程語言。
設計空間是開放的，我們可以做很多有趣的事情。

在實踐中，有些東西打破了我們的幻想。
時間和可維護性阻止我們創建特別複雜的東西。
更重要的是，無論如何設計類型系統，用戶（通常不是程序員）要能輕鬆地理解它。
我們將其做得越簡單，它就越有用。
所以我們在這裏談到的是已經反覆探索的領域，開闢新路就留給學者和探索者吧。

### 類型對象是封裝的還是暴露的？

在我們的簡單實現中，`Monster`有一個對品種的引用，但是它沒有顯式暴露這個引用。
外部代碼不能直接獲取怪物的品種。
從代碼庫的角度看來，怪物事實上是沒有類型的，事實上它們擁有品種只是個實現細節。

我們可以很容易地改變這點，讓`Monster`返回它的`Breed`：

<span name="null"></span>

^code 11

<aside name="null">

在本書的另一個例子中，我們遵守了慣例，返回對象的引用而不是對象的指針，保證了永遠不會返回`NULL`。

</aside>

這樣做改變了`Monster`的設計。
事實是所有怪物都擁有品種是API的可見部分了，下面是這兩者各自的好處：

* **如果類型對象是封裝的：**

    * *類型對象模式的複雜性對代碼庫的其他部分是隱藏的。*
      它成爲了只有有類型的對象才需要考慮的實現細節。

    * *有類型的對象可以選擇性地修改類型對象的重載行爲*。
      假設我們想要怪物在它接近死亡時改變它的攻擊字符串。
      由於攻擊字符串總是通過`Monster`獲取的，我們有一個方便的地方放置代碼：

        ^code 12

        如果外部代碼直接調用品種的`getAttack()`，我們就沒有機會能插入邏輯。

    * *我們得爲每個類型對象暴露的方法寫轉發。*
      這是這個設計的冗長之處。如果類型對象有很多方法，對象類也得爲每一個方法建立屬於自己的公共可見方法。

* **如果類型對象是暴露的：**

    * *外部代碼可以與類型對象直接交互，無需擁有類型對象的實例。*
      如果類型對象是封裝的，那麼沒有一個擁有它的對象就沒法使用它。
      這阻止我們使用構造器模式這樣的方法，在品種上調用方法來創建新怪物。
      如果用戶不能直接獲得品種，他們就沒辦法調用它。

    * *類型對象現在是對象公共API的一部分了。*
      大體上，窄接口比寬接口更容易掌控——你暴露給代碼庫其他部分的越少，你需要處理的複雜度和維護工作就越少。
      通過暴露類型對象，我們擴寬了對象的API，包含了所有類型對象提供的東西。

### 有類型的對象是如何創建的？

使用這個模式，每個“對象”現在都是一對對象：主對象和它的類型對象。
所以我們怎樣創建並綁定兩者呢？

* **構造對象然後傳入類型對象：**

    *  *外部代碼可以控制分配。*
      由於調用代碼也是構建對象的代碼，它可以控制其內存位置。
      如果我們想要UI在多種內存場景中使用（不同的分配器，在棧中，等等），這給了完成它的靈活性。

* **在類型對象上調用“構造器”函數：**

    * *類型對象控制了內存分配。*
      這是硬幣的另一面。如果我們*不想*讓用戶選擇在內存中何處創建對象，
      在類型對象上調用工廠方法可以達到這一點。
      如果我們想保證所有的對象都來自具體的<a class="pattern" href="object-pool.html">對象池</a>或者其他的內存分配器時也有用。

### 能改變類型嗎？

到目前爲止，我們假設一旦對象創建並綁定到類型對象上，這永遠不會改變。
對象創建時的類型就是它銷燬時的類型。這其實沒有必要。
我們*可以*允許對象隨着時間改變它的類型。

讓我們回想下我們的例子。
當怪物死去時，設計者告訴我們，有時它的屍體會復活成殭屍。
我們可以通過在怪物死亡時產生殭屍類型的新怪獸，但另一個選項是拿到現有的怪物，然後將它的品種改爲殭屍。

* **如果類型不改變：**

    *  *編碼和理解都更容易。*
      在概念上，大多數人不期望“類型”會改變。這符合大多數人的理解。

    *  *更容易查找漏洞。*
      如果我們試圖追蹤怪物進入奇怪狀態時的漏洞，*現在*看到的品種就是怪物始終保持的品種可以大大簡化工作。

* **如果類型可以改變：**

    * *需要創建的對象更少。*
      在我們的例子中，如果類型不能改變，我們需要消耗CPU循環創建新的殭屍怪物對象，
      把原先對象中需要保留的屬性都拷貝過來，然後刪除它。
      如果我們可以改變類型，所有的工作都被一個簡單的聲明取代。

    * *我們需要小心地做約束。*
      在對象和它的類型間有強耦合是很自然的事情。
      舉個例子，一個品種也許假設怪物*當前的*血量永遠高於品種中的初始血量。

        如果我們允許品種改變，我們需要確保已存對象滿足新品種的需求。
        當我們改變類型時，我們也許需要執行一些驗證代碼保證對象現在的狀態對新類型是有意義的。

### 它支持何種繼承？

* **沒有繼承：**

    * *簡單。*
       最簡單的通常是最好的。如果你在類型對象間沒有大量數據共享，爲什麼要爲難自己呢？

    * *這會帶來重複的工作。*
      我從未見過哪個編碼系統中設計者*不*想要繼承的。
      當你有十五種不同的精靈時，協調血量就要修改十五處同樣的數字真是糟透了。

* **單繼承：**

    *  *還是相對簡單。*
      它易於實現，但是，更重要的是，也易於理解。如果非技術用戶正在使用這個系統，要操作的部分越少越好。
      這就是很多編程語言只支持單繼承的原因。這看起來是能力和簡潔之間的平衡點。

    *  *查詢屬性更慢。*
      爲了在類型對象中獲取一塊數據，我們也許需要回溯繼承鏈尋找是哪一個類型最終決定了值。
      在性能攸關的代碼上，我們也許不想花時間在這上面。

*  **多重繼承：**

    * *可以避免絕大多數代碼重複。*
      使用優良的多繼承系統，用戶可以爲類型對象建立幾乎沒有冗餘的層次。
      改變數值時，我們可以避免很多複製和粘貼。

    * *複雜。*
      不幸的是，它的好處更多地是理論上的而非實際上的。多重繼承很難理解。

        如果殭屍龍繼承殭屍和龍，哪些屬性來自殭屍，哪些來自於龍？
        爲了使用系統，用戶需要理解如何遍歷繼承圖，還需要有設計優秀層次的遠見。

        我看到的大多數C++編碼標準趨向于禁止多重繼承，Java和C#完全移除了它。
        這承認了一個悲傷的事實：它太難掌握了，最好根本不要用。
        儘管值得考慮，但你很少想要在類型對象上實現多重繼承。就像往常一樣，簡單的總是最好的。

## 參見

* 這個模式處理的高層問題是在多個對象間分享數據和行爲。
  另一個用另一種方式解決了相同問題的模式是<a class="gof-pattern" href="prototype.html">原型</a>模式。

* 類型對象是<a class="gof-pattern" href="flyweight.html">享元</a>模式的近親。
  兩者都讓你在實例間分享代碼。使用享元，意圖是節約內存，而分享的數據也許不代表任何概念上對象的“類型”。
  使用類型對象模式，焦點在組織性和靈活性。

* 這個模式和<a class="gof-pattern" href="state.html">狀態</a>模式有很多相似之處。
  兩者都委託對象的部分定義給另外一個對象。
  通過類型對象，我們通常委託了對象*是*什麼：不變的數據概括描述對象。
  通過狀態，我們委託了對象*現在是什麼*：暫時描述對象當前狀態的數據。

    當我們討論對象改變它的類型時，你可以認爲類型對象起到了和狀態相似的職責。
