^title 組件模式 Component
^section Decoupling Patterns

## 意圖

*允許單一的實體跨越多個領域而不會導致這些領域彼此耦合。*

## 動機

<span name="baker"></span>

讓我們假設我們正在製作平臺跳躍遊戲。
意大利水管工已經有人做了，因此我們將出動丹麥麪包師，Bjorn。
照理說，會有一個類來表示友好的糕點廚師，包含他在遊戲中做的一切。

<aside name="baker">

像這樣的遊戲創意導致了我是程序員而不是設計師。

</aside>

由於玩家控制着他，這意味着需要讀取控制器的輸入然後轉化爲動作。
而且他當然需要與關卡進行互動，所以要引入物理和碰撞。
一旦這樣做了，他就必須在屏幕上出現，所以要引入動畫和渲染。
他可能還會播放一些聲音。

等一下，這一切正在失控。軟件體系結構101課程告訴我們，程序的不同領域應保持分離。
如果我們做一個文字處理器，處理打印的代碼不應該受加載和保存文件的代碼影響。
遊戲和企業應用程序的領域不盡相同，但該規則仍然適用。

我們希望AI，物理，渲染，聲音和其他領域域儘可能相互不瞭解，
但現在我們將所有這一切擠在一個類中。
我們已經看到了這條路通往何處：5000行的巨大代碼文件，哪怕是你們團隊中最勇敢的程序員也不敢打開。

這工作對能馴服他的少數人來說是有趣的，但對其他人而言是地獄。
這麼大的類意味着，即使是看似微不足道的變化亦可有深遠的影響。
很快，爲類添加*錯誤*的速度會明顯快於添加*功能*的速度。

###  一團亂麻

<span name="coupling"></span>

比起單純的規模問題，更糟糕的是耦合。
在遊戲中，所有不同的系統被綁成了一個巨大的代碼球：

^code gordian

任何試圖改變上面代碼的程序員，都需要物理，圖形和聲音的相關知識，以確保沒破壞什麼。

<aside name="coupling">

這樣的耦合在*任何*遊戲中出現都是個問題，但是在使用併發的現代遊戲中尤其糟糕。
在多核硬件上，讓代碼同時在多個線程上運行是至關重要的。
將遊戲分割爲多線程的一種通用方法是通過領域劃分——在一個核上運行AI代碼，在另一個上播放聲音，在第三個上渲染，等等。

一旦你這麼做了，在領域間保持解耦就是至關重要的，這是爲了避免死鎖或者其他噩夢般的併發問題。
如果某個函數從一個線程上調用`UpdateSounds()`方法，從另一個線程上調用`RenderGraphics()`方法，那它是在自找麻煩。

</aside>

這兩個問題互相混合；這個類涉及太多的域，每個程序員都得接觸它，
但它又太過巨大，這就變成了一場噩夢。
如果變得夠糟糕，程序員會黑入代碼庫的其他部分，僅僅爲了躲開這個像毛球一樣的`Bjorn`類。

### 快刀斬亂麻

我們可以像亞歷山大大帝一樣解決這個問題——快刀斬亂麻。
按領域將`Bjorn`類割成相互獨立的部分。
例如，抽出所有處理用戶輸入的代碼，將其移動到一個單獨的`InputComponent`類。
`Bjorn`擁有這個部件的一個實例。我們將對`Bjorn`接觸的每個領域重複這一過程。

當完成後，我們就將`Bjorn`大多數的東西都抽走了。
剩下的是一個薄殼包着所有的組件。
通過將類劃分爲多個小類，我們已經解決了這個問題。但我們所完成的遠不止如此。

### 寬鬆的結果

我們的組件類現在解耦了。
儘管`Bjorn`有`PhysicsComponent`和`GraphicsComponent`，
但這兩部分都不知道對方的存在。
這意味着處理物理的人可以修改組件而不需要了解圖形，反之亦然。

在實踐中，這些部件之間需要有*一些*相互作用。
例如，AI組件可能需要告訴物理組件Bjorn試圖去哪裏。
然而，我們可以將這種交互限制在*確實*需要交互的組件之間，
而不是把它們圍在同一個圍欄裏。

### 綁到一起

<span name="inheritance"></span>

這種設計的另一特性是，組件現在是可複用的包。
到目前爲止，我們專注於麪包師，但是讓我們考慮幾個遊戲世界中其他類型的對象。
*裝飾* 是玩家看到但不能交互的事物：灌木，雜物等視覺細節。
*道具* 像*裝飾*，但可以交互：箱，巨石，樹木。
*區域* 與裝飾相反——無形但可互動。
它們是很好的觸發器，比如在Bjorn進入區域時觸發過場動畫。

<aside name="inheritance">

當面向對象語言第一次接觸這個場景時，繼承是它箱子裏最閃耀的工具。
它被認爲是代碼無限重用之錘，編程者常常揮舞着它。
然而我們痛苦地學到，事實上它是一把重錘。
繼承有它的用處，但對簡單的代碼重用來說太過複雜。

相反，在今日軟件設計的趨勢是儘可能使用組件代替繼承。
不是讓兩個類*繼承*同一類來分享代碼，而是讓它們*擁有同一個類的實例*。

</aside>

現在，考慮如果不用組件，我們將如何建立這些類的繼承層次。第一遍可能是這樣的：

<img src="images/component-uml.png" alt="類的層次圖。區域有碰撞檢測代碼並繼承遊戲對象。裝飾也繼承遊戲對象而且有渲染代碼。道具繼承區域，但是有了多餘的渲染代碼。" />

<span name="diamond"></span>

我們有`GameObject`基類，包含位置和方向之類的通用部分。
`Zone`繼承它，增加了碰撞檢測。
同樣，`Decoration`繼承`GameObject`，並增加了渲染。
`Prop`繼承`Zone`，因此它可以重用碰撞代碼。
然而，`Prop`不能*同時*繼承`Decoration`來重用*渲染*，
否則就會造成致命菱形結構。

<aside name="diamond">

“致命菱形”發生在類繼承了多個類，而這多個類中有兩個繼承同一基類時。
介紹它造成的痛苦超過了本書的範圍，但它被說成“致命”是有原因的。

</aside>

我們可以反過來讓`Prop`繼承`Decoration`，但隨後不得不重複*碰撞檢測*代碼。
無論哪種方式，沒有乾淨的辦法重用碰撞和渲染代碼而不訴諸多重繼承。
唯一的其他選擇是一切都繼承`GameObject`，
但隨後`Zone`會浪費內存在並不需要的渲染數據上，
`Decoration`在物理效果上有同樣的浪費。

<span name="menu"></span>

現在，讓我們嘗試用組件。子類將徹底消失。
取而代之的是一個`GameObject`類和兩個組件類：`PhysicsComponent`和`GraphicsComponent`。
裝飾是個簡單的`GameObject`，包含`GraphicsComponent`但沒有`PhysicsComponent`。
區域與其恰好相反，而道具包含兩種組件。
沒有代碼重複，沒有多重繼承，只有三個類，而不是四個。

<aside name="menu">

可以拿飯店菜單打比方。如果每個實體是一個類，那就只能訂套餐。
我們需要爲每種*可能*的組合定義各自的類。
爲了滿足每位用戶，我們需要十幾種套餐。

組件是照單點菜——每位顧客都可以選他們想要的，菜單記錄可選的菜式。

</aside>

對對象而言，組件是即插即用的。
將不同的可重用部件插入對象，我們就能構建複雜且具有豐富行爲的實體。
就像軟件中的戰神金剛。

## 模式

<span name="component"></span>

**單一實體跨越了多個領域**。爲了保持領域之間相互分離，將每部分代碼放入**各自的組件類**中。
實體被簡化爲*組件的容器*。

<aside name="component">

“組件”，就像“對象”，在編程中意味任何東西也不意味任何東西。
正因如此，它被用來描述一些概念。
在商業軟件中，“組件”設計模式描述通過網絡解耦的服務。

我試圖從遊戲中找到無關這個設計模式的另一個名字，但“組件”看來是最常用的術語。
由於設計模式是記錄已存的實踐，我沒有創建新術語的餘地。
所以，跟着XNA，Delta3D和其他人的腳步，我稱之爲“組件”。

</aside>

## 何時使用

組件通常在定義遊戲實體的核心部分中使用，但它們在其他地方也有用。
這個模式應用在在如下情況中：

* 有一個涉及了多個領域的類，而你想保持這些領域互相隔離。

* 一個類正在變大而且越來越難以使用。

* 想要能定義一系列分享不同能力的類，但是使用繼承無法讓你精確選取要重用的部分。

## 記住

組件模式比簡單地向類中添加代碼增加了一點點複雜性。
每個概念上的“對象”要組成真正的對象需要實例化，初始化，然後正確地連接。
不同組件間溝通會有些困難，而控制它們如何使用內存就更加複雜。

對於大型代碼庫，爲了解耦和重用而付出這樣的複雜度是值得的。
但是在使用這種模式之前，保證你沒有爲了不存在的問題而“過度設計”。

<span name="perf"></span>

使用組件的另一後果是，需要多一層跳轉才能做要做的事。
拿到容器對象，獲得相應的組件，*然後* 你才能做想做的事情。
在性能攸關的內部循環中，這種跳轉也許會導致糟糕的性能。

<aside name="perf">

這是硬幣的兩面。組件模式通常可以*增進*性能和緩存一致性。
組件讓使用<a class="pattern" href="data-locality.html">數據局部性</a>模式的CPU更容易組織數據。

</aside>

## 示例代碼

我寫這本書的最大挑戰之一就是搞明白如何隔離各個模式。
許多設計模式包含了不屬於這種模式的代碼。
爲了將提取模式的本質，我儘可能地消減代碼，
但是在某種程度上，這就像是沒有衣服還要說明如何整理衣櫃。

說明組件模式尤其困難。
如果看不到它解耦的各個領域的代碼，你就不能獲得正確的體會，
因此我會多寫一些有關於Bjorn的代碼。
這個模式事實上只關於將組件變爲*類*，但類中的代碼可以幫助表明類是做什麼用的。
它是僞代碼——它調用了其他不存在的類——但這應該可以讓你理解我們正在做什麼。

### 單塊類

<span name="cat"></span>

爲了清晰的看到這個模式是如何應用的，
我們先展示一個`Bjorn`類，
它包含了所有我們需要的事物，但是*沒有*使用這個模式：

<aside name="cat">

我應指出在代碼中使用角色的名字總是個壞主意。市場部有在發售之前改名字的壞習慣。
“焦點測試表明，在11歲到15歲之間的男性不喜歡&lsquo;Bjorn&rsquo;，請改爲&lsquo;Sven‘”。

這就是爲什麼很多軟件項目使用內部代碼名。
而且比起告訴人們你在完成“Photoshop的下一版本”，告訴他們你在完成“大電貓”更有趣。

</aside>

^code 1

`Bjorn`有個每幀調用的`update()`方法。

^code monolithic-update

它讀取操縱桿以確定如何加速麪包師。
然後，用物理引擎解析新位置。
最後，將Bjorn渲染至屏幕。

這裏的示例實現平凡而簡單。
沒有重力，動畫，或任何讓人物有趣的其他細節。
即便如此，我們可以看到，已經出現了同時消耗多個程序員時間的函數，而它開始變得有點混亂。
想象增加到一千行，你就知道這會有多難受了。

### 分離領域

從一個領域開始，將`Bjorn`的代碼去除一部分，歸入分離的組件類。
我們從首個執行的領域開始：輸入。
`Bjorn`做的頭件事就是讀取玩家的輸入，然後基於此調整它的速度。
讓我們將這部分邏輯移入一個分離的類：

^code 2

很簡單吧。我們將`Bjorn`的`update()`的第一部分取出，放入這個類中。
對`Bjorn`的改變也很直接：

^code 3

`Bjorn`現在擁有了一個`InputComponent`對象。
之前它在`update()`方法中直接處理用戶輸入，現在委託給組件：

^code 4

我們纔剛開始，但已經擺脫了一些耦合——`Bjorn`主體現在已經與`Controller`無關了。這會派上用場的。

### 將剩下的分割出來

現在讓我們對物理和圖像代碼繼續這種剪切粘貼的工作。
這是我們新的 `PhysicsComponent`：

^code 5

爲了將物理*行爲*移出`Bjorn`類，你可以看到我們也移出了*數據*：`Volume`對象已經是組件的一部分了。

最後，這是現在的渲染代碼：

^code 6

我們幾乎將所有的東西都移出來了，所以麪包師還剩下什麼？沒什麼了：

^code 7

`Bjorn`類現在基本上就做兩件事：擁有定義它的組件，以及在不同域間分享的數據。
有兩個原因導致位置和速度仍然在`Bjorn`的核心類中：
首先，它們是“泛領域”狀態——幾乎每個組件都需要使用它們，
所以我們想要提取它出來時，哪個組件*應該*擁有它們並不明確。

第二，也是更重要的一點，它給了我們無需讓組件耦合就能溝通的簡易方法。
讓我們看看能不能利用這一點。

### 機器人Bjorn

到目前爲止，我們將行爲歸入了不同的組件類，但還沒將行爲*抽象*出來。
`Bjorn`仍知道每個類的具體定義的行爲。讓我們改變這一點。

取出處理輸入的部件，將其藏在接口之後，將`InputComponent`變爲抽象基類。

^code 8

然後，將現有的處理輸入的代碼取出，放進一個實現接口的類中。

^code 9

我們將`Bjorn`改爲只擁有一個指向輸入組件的指針，而不是擁有一個內聯的實例。

^code 10

現在當我們實例化`Bjorn`，我們可以傳入輸入組件使用，就像下面這樣：

^code 11

這個實例可以是任何實現了抽象`InputComponent`接口的類型。
我們爲此付出了代價——`update()`現在是虛方法調用了，這會慢一些。這一代價的回報是什麼？

大多數的主機需要遊戲支持“演示模式”。
如果玩家停在主菜單沒有做任何事情，遊戲就會自動開始運行，直到接入一個玩家。
這讓屏幕上的主菜單看上去更有生機，同時也是銷售商店裏很好的展示。

隱藏在輸入組件後的類幫我們實現了這點，
我們已經有了具體的`PlayerInputComponent`供玩遊戲時使用。
現在讓我們完成另一個：

^code 12

當遊戲進入演示模式，我們將Bjorn和一個新組件連接起來，而不像之前演示的那樣構造它：

^code 13

<span name="coffee"></span>

現在，只需要更改組件，我們就有了爲演示模式而設計的電腦控制的玩家。
我們可以重用所有Bjorn的代碼——物理和圖像都不知道這裏有了變化。
也許我有些奇怪，但這就是每天能讓我起牀的事物。

<aside name="coffee">

那個，還有咖啡。熱氣騰騰的咖啡。

</aside>

### 刪掉Bjorn？

如果你看看現在的`Bjorn`類，你會意識到那裏完全沒有“Bjorn”——那只是個組件包。
事實上，它是個好候選人，能夠作爲*每個*遊戲中的對象都能繼承的“遊戲對象”基類。
我們可以像弗蘭肯斯坦一樣，通過挑選拼裝部件構建任何對象。

讓我們將剩下的兩個具體組件——物理和圖像——像輸入那樣藏到接口之後。

^code 14

<span name="id"></span>

然後將`Bjorn`改爲使用這些接口的通用`GameObject`類。

^code 15

<aside name="id">

有些人走的更遠。
不使用包含組件的`GameObject`，遊戲實體只是一個ID，一個數字。
每個組件都知道它們連接的實體ID，然後管理分離的組件。

這些[實體組件系統](http://en.wikipedia.org/wiki/Entity_component_system)將組件發揮到了極致，讓你向實體添加組件而無需通知實體。
<a href="data-locality.html" class="pattern">數據局部性</a>一章有更多細節。

</aside>

我們現有的具體類被重命名並實現這些接口：

^code 16

現在我們無需爲Bjorn建立具體類，就能構建擁有所有Bjorn行爲的對象。

<span name="factory"></span>

^code 17

<aside name="factory">

這個`createBjorn()`函數當然就是經典的GoF<a class="gof-pattern" href="http://c2.com/cgi/wiki?FactoryMethod">工廠模式</a>的例子。

</aside>

通過用不同組件實例化`GameObject`，我們可以構建遊戲需要的任何對象。

## 設計決策

這章中你最需要回答的設計問題是“我需要什麼樣的組件？”
回答取決於你遊戲的需求和風格。
引擎越大越複雜，你就越想將組件劃分得更細。

除此之外，還有幾個更具體的選項要回答：

### 對象如何獲取組件？

一旦將單塊對象分割爲多個分離的組件，就需要決定誰將它們拼到一起。

* **如果對象創建組件：**

    * *這保證了對象總是能拿到需要的組件。*
      你永遠不必擔心某人忘記連接正確的組件然後破壞了整個遊戲。容器類自己會處理這個問題。

    * *重新設置對象比較困難。*
      這個模式的強力特性之一就是隻需重新組合組件就可以創建新的對象。
      如果對象總是用硬編碼的組件組裝自己，我們就無法利用這個特性。

* **如果外部代碼提供組件：**

     * *對象更加靈活。*
       我們可以提供不同的組件，這樣就能改變對象的行爲。
       通過共用組件，對象變成了組件容器，我們可以爲不同目的一遍又一遍地重用它。

     * *對象可以與具體的組件類型解耦。*

       如果我們允許外部代碼提供組件，好處是也可以傳遞*派生*的組件類型。
       這樣，對象只知道組件*接口*而不知道組件的具體類型。這是一個很好的封裝結構。

### 組件之間如何通信？

完美解耦的組件不需要考慮這個問題，但在真正的實踐中行不通。
事實上組件屬於*同一*對象暗示它們屬於需要相互協同的更大整體的一部分。
這就意味着通信。

所以組件如何相互通信呢？
這裏有很多選項，但不像這本書中其他的“選項”，它們相互並不衝突——你可以在一個設計中支持多種方案。

* *通過修改容器對象的狀態：*

    * *保持了組件解耦。*
      當我們的`InputComponent`設置了Bjorn的速度，而後`PhysicsComponent`使用它，
      這兩個組件都不知道對方的存在。在它們的理解中，Bjorn的速度是被黑魔法改變的。

    * *需要將組件分享的任何數據存儲在容器類中。*
      通常狀態只在幾個組件間共享。比如，動畫組件和渲染組件需要共享圖形專用的信息。
      將信息存入容器類會讓*所有*組件都獲得這樣的信息。

        更糟的是，如果我們爲不同組件配置使用相同的容器類，最終會浪費內存存儲不被*任何*對象組件需要的狀態。
        如果我們將渲染專用的數據放入容器對象中，任何隱形對象都會無益地消耗內存。

    * *這讓組件的通信基於組件運行的順序。*
      在同樣的代碼中，原先一整塊的`update()`代碼小心地排列這些操作。
      玩家的輸入修改了速度，速度被物理代碼使用並修改位置，位置被渲染代碼使用將Bjorn繪製到所在之處。
      當我們將這些代碼劃入組件時，還是得小心翼翼地保持這種操作順序。

        <span name="pure"></span>

        如果我們不那麼做，就引入了微妙而難以追蹤的漏洞。
        比如，我們*先*更新圖形組件，就錯誤地將Bjorn渲染在他*上一幀*而不是這一幀所處的位置上。
        如果你考慮更多的組件和更多的代碼，那你可以想象要避免這樣的錯誤有多麼困難了。

        <aside name="pure">

        這樣被大量代碼讀寫相同數據的共享狀態很難保持正確。
        這就是爲什麼學術界花時間研究完全函數式語言，比如Haskell，那裏根本沒有可變狀態。

        </aside>

* *通過它們之間相互引用：*

    這裏的思路是組件有要交流的組件的引用，這樣它們直接交流，無需通過容器類。

    假設我們想讓Bjorn跳躍。圖形代碼想知道它需要用跳躍圖像還是不用。
    這可以通過詢問物理引擎它當前是否在地上來確定。一種簡單的方式是圖形組件直接知道物理組件的存在：

    ^code 18

    當構建Bjorn的`GraphicsComponent`時，我們給它相應的`PhysicsComponent`引用。

    * *簡單快捷。*
      通信是一個對象到另一個的直接方法調用。組件可以調用任一引用對象的方法。做什麼都可以。

    * *兩個組件緊綁在一起。*
      這是做什麼都可以帶來的壞處。我們向使用整塊類又退回了一步。
      這比只用單一類好一點，至少我們現在只是把需要通信的類綁在一起。

* *通過發送消息：*

    * 這是最複雜的選項。我們可以在容器類中建小小的消息系統，允許組件相互發送消息。

        下面是一種可能的實現。我們從每個組件都會實現的`Component`接口開始：

        ^code 19

        它有一個簡單的`receive()`方法，每個需要接受消息的組件類都要實現它。
        這裏，我們使用一個`int`來定義消息，但更完整的消息實現應該可以附加數據。

        然後，向容器類添加發送消息的方法。

        ^code 20

        <span name="queue"></span>

        現在，如果組件能夠接觸容器，它就能向容器發送消息，直接向所有的組件廣播。
        （包括了原先發送消息的組件，小心別陷入無限的消息循環中！）這會造成一些結果：

        <aside name="queue">

        如果你真的樂意，甚至可以將消息存儲在*隊列*中，晚些發送。
        要知道更多，看看<a href="event-queue.html" class="pattern">事件隊列</a>。

        </aside>

    <span name="mediator"></span>

    * *同級組件解耦。*
      通過父級容器對象，就像共享狀態的方案一樣，我們保證了組件之間仍然是解耦的。
      使用了這套系統，組件之間唯一的耦合是它們發送的消息。

        <aside name="mediator">

        GoF稱之爲<a class="gof-pattern" href="http://c2.com/cgi-bin/wiki?MediatorPattern">中介</a>模式——兩個或更多的對象通過中介對象通信。
        現在這種情況下，容器對象本身就是中介。

        </aside>

     * *容器類很簡單。*
        不像使用共享狀態那樣，容器類無需知道組件使用了什麼數據，它只是將消息發送出去。
         這可以讓組件發送領域特有的數據而無需打擾容器對象。

不出意料的，這裏沒有最好的答案。這些方法你最終可能都會使用一些。
共享狀態對於每個對象都有的數據是很好用的——比如位置和大小。

有些不同領域仍然緊密相關。想想動畫和渲染，輸入和AI，或物理和粒子。
如果你有這樣一對分離的組件，你會發現直接相互引用也許更加容易。

消息對於“不那麼重要”的通信很有用。對物理組件發現事物碰撞後發送消息讓音樂組件播放聲音這種事情來說，發送後不管的特性是很有效的。

就像以前一樣，我建議你從簡單的開始，然後如果需要的話，加入其他的通信路徑。

## 參見

* [Unity](http://unity3d.com)核心架構中[`GameObject`](http://docs.unity3d.com/Documentation/Manual/GameObjects.html)類完全根據這樣的原則設計[components](http://docs.unity3d.com/Manual/UsingComponents.html)。

* 開源的[Delta3D](http://www.delta3d.org)引擎有`GameActor`基類通過`ActorComponent`實現了這種模式。

* 微軟的<a href="http://creators.xna.com/en-US/">XNA</a>遊戲框架有一個核心的`Game`類。它擁有一系列`GameComponent`對象。我們在遊戲實體層使用組件，XNA在遊戲主對象上實現了這種模式，但意圖是一樣的。

* 這種模式與GoF的<a class="gof-pattern" href="http://c2.com/cgi-bin/wiki?StrategyPattern">策略模式</a>類似。
  兩種模式都是將對象的行爲取出，劃入單獨的重述對象。
  與對象模式不同的是，分離的策略模式通常是無狀態的——它封裝了算法，而沒有數據。
  它定義了對象*如何*行動，但沒有定義對象*是*什麼。

    組件更加重要。它們經常保存了對象的狀態，這有助於確定其真正的身份。
    但是，這條界限很模糊。有一些組件也許根本沒有任何狀態。
    在這種情況下，你可以在不同的容器對象中使用相同的組件*實例*。這樣看來，它的行爲確實更像一種策略。
