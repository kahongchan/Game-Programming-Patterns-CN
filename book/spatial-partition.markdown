^title 空間分區 Spatial Partition
^section Optimization Patterns

## 意圖

*將對象根據它們的位置存儲在數據結構中，來高效地定位對象。*

## 動機

遊戲讓我們能拜訪其他世界，但這些世界通常和我們的世界沒有太多不同。
它們通常有和我們宇宙同樣的基礎物理和可理解性。
這就是我們爲什麼會認爲這些由比特和像素構建的東西是真實的。

我們這裏注意的虛擬事實是*位置*。遊戲世界有*空間*感，對象都在空間的某處。
它用很多種方式證明了這點。最明顯的是物理——對象移動，碰撞，交互——但是還有其他方式。
音頻引擎也許會考慮聲源和玩家的距離，越遠的聲音響聲越小。
在線交流也許侷限在較近的玩家之間。

這意味着遊戲引擎通常需要回答這個問題，“哪些對象在這個位置周圍？”
如果每幀都需要回答這個問題，這就會變成性能瓶頸。

### 在戰場上的單位

假設我們在做實時戰略遊戲。雙方成百上千的單位在戰場上撞在一起。
戰士需要揮舞刀鋒向最近的那個敵人砍去。
最簡單的處理方法是檢查每對單位，然後看看它們互相之間的距離：

^code pairwise

<span name="all"></span>

這裏使用的是雙重循環，每個循環都會遍歷戰場上的所有單位。
這就是意味着每幀進行的檢測對數會隨着單位數量的*平方*增長。
每個附加單位都需要和之前*所有*單位的進行檢查。
如果有大量單位，這就完全失控了。

<aside name="all">

內層循環實際沒有遍歷所有的單位。
它只遍歷那些外部循環還沒有拜訪的對象。
這避免了比較一對單位*兩次*：A與B一次，B與A一次。
如果我們已經處理了A和B之間的碰撞，我們不必爲B和A再做一次。

用大O術語，這還是*O(n&sup2;)* 的。

</aside>

### 描繪戰線

我們這裏碰到的問題是沒有指明數組中潛藏的對象順序。
爲了在某個位置附近找到單位，我們需要遍歷整個數組。
現在，我們簡化一下游戲。
不使用二維的戰*場*，想象這是個一維的戰*線*。

<img src="images/spatial-partition-battle-line.png" alt="一條在不同座標標記了不同單位位置的數軸。" />

<span name="array"></span>

在這種情況下，我們可以通過根據單位在戰線上的位置*排序*數組元素來簡化問題。
一旦我們那樣做，我們可以使用像[二分查找](http://en.wikipedia.org/wiki/Binary_search)之類的東西找到最近的對象而不必掃描整個數組。

<aside name="array">

二分查找有*O(log n)* 的複雜度，意味着找所有戰鬥單位的複雜度從*O(n&sup2;)*降到*O(n log n)*。
像[pigeonhole sort](http://en.wikipedia.org/wiki/Pigeonhole_sort)可將其降至*O(n)* 。

</aside>

這裏的經驗很明顯：如果我們根據位置在數據結構中存儲對象，就可以更快地找到它們。
這個模式便是將這個思路應用到多維空間上。

## 模式

對於一系列**對象**，每個對象都有**空間上的位置**。
將它們存儲在根據位置組織對象的**空間數據結構**中，讓你**有效查詢在某處或者某處附近的對象**。
當對象的位置改變時，**更新空間數據結構**，這樣它可以繼續找到對象。

## 何時使用

這是存儲活躍的、移動的遊戲對象的常用模式，也可用於靜態美術和世界地理。
複雜的遊戲中，不同的內容有不同的空間分區。

這個模式的基本要求是一系列有位置的對象，而你做了太多的通過位置尋找對象的查詢，導致性能下降。

## 記住

空間分區的存在是爲了將*O(n)*或者*O(n&sup2;)* 的操作降到更加可控的數量級。
你擁有的對象*越多*，這就越重要。相反的，如果*n*足夠小，也許不需要擔心這個。

<span name="hash-change"></span>

由於這個模式需要通過位置組織對象，可以*改變*位置的對象更難處理。
你需要重新組織數據結構來追蹤在新位置的對象，這增加了更多的複雜性*並*消耗CPU循環。
確保這種交易是值得的。

<aside name="hash-change">

想象一下哈希表，其中對象的鍵可以自動改變，那你就知道爲什麼這難以處理。

</aside>

空間分區也會因爲記錄劃分的數據結構而使用額外的內存。
就像很多優化一樣，它用內存換速度。如果內存比時鐘週期更短缺，這會是個錯誤的選擇。

## 示例代碼

<span name="variations"></span>

模式總會*變化*——每種實現都略有不同，空間分區也不例外。
不像其他的模式，它的每種變化都很好地被記錄下來了。
學術界發表文章證明各種變化各自的性能優勢。
由於我只關注模式背後的觀念，我會給你展示最簡單的空間分區：*固定網格*。

<aside name="variations">

看看本章的最後一節，那裏有遊戲中常用的空間分區方法列表。

</aside>

### 一張網格紙

想象整個戰場。現在，疊加一張方格大小固定的網格在上面，就好像一張網格紙。
不是在單獨的數組中存儲我們的對象，我們將它們存到網格的格子中。
每個格子存儲一組單位，它們的位置在格子的邊界內部。

<img src="images/spatial-partition-grid.png" alt="一個單位佔據不同格子的網格。有些格子有多個單位。" />

當我們處理戰鬥時，我們只需考慮在同一格子中的單位。
不是將遊戲中的每個單位與其他所有單位比較，我們將戰場*劃分*爲多個小戰場，每個格子中的單位都較少。

### 一網格相鄰單位

好了，讓我們編碼吧。首先，一些準備工作。這是我們的基礎`Unit`類。

^code unit-simple

每個單位都有位置（2D表示），以及一個指針指向它存在的`Grid`。
我們讓`Grid`成爲一個`friend`類，
因爲，就像將要看到的，當單位的位置改變時，它需要和網格做複雜的交互，以確保所有事情都正確地更新了。

這裏是網格的表示：

^code grid-simple

<span name="stl"></span>

注意每個格子都是一個指向單位的指針。
下面我們擴展`Unit`，增加`next`和`prev`指針：

^code unit-linked

這讓我們將對象組織爲[雙向鏈表](http://en.wikipedia.org/wiki/Doubly_linked_list)，而不是數組。

<img src="images/spatial-partition-linked-list.png" alt="一個格子指向存儲單元的雙向鏈表。" />

每個網格中的指針都指向網格中的元素列表的第一個，
每個對象都有個指針指向它前面的對象，以及另一個指針指向它後面的對象。
我們很快會知道爲什麼要這麼做。

<aside name="stl">

在這本書中，我避免使用任何C++標準庫內建的集合類型。
我想讓理解例子所需的知識越少越好，然後，就像魔術師的“我的袖子裏什麼也沒有”，
我想明晰代碼中*確實*在發生什麼。
細節很重要，特別是那些與性能相關的模式。

但這是我*解釋*模式的方式。
如果你在真實代碼中*使用*它們，使用內建在幾乎每種程序語言中的集合避免麻煩。
人生苦短，不要浪費在編寫鏈表上。

</aside>

### 進入戰場

我們需要做的第一件事就是保證新單位創建時被放置到了網格中。
我們讓`Unit`在它的構造函數中處理這個：

^code unit-ctor

`add()`方法像這樣定義：

<span name="floor"></span>

^code add

<aside name="floor">

世界座標除以網格大小轉換到了網格空間。
然後，縮短爲`int`消去了分數部分，這樣可以獲得網格索引。

</aside>

除了鏈表帶來的繁瑣，基本思路是非常簡單的。
我們找到單位所在的網格，然後將它添加到列表前部。
如果那兒已經存在列表單位了，我們把新單位鏈接到舊單位的後面。

### 刀劍碰撞

一旦所有的單位都放入網格中，我們就可以讓它們開始交互。
使用這個新網格，處理戰鬥的主要方法看上去是這樣的：

^code grid-melee

它在每個網格上面遍歷並調用`handleCell()`。
就像你看到的那樣，我們真的已經將戰場分割爲分離的小衝突。
每個網格之後像這樣處理它的戰鬥：

^code handle-cell

<span name="nested"></span>

除了遍歷鏈表的指針把戲，注意它和我們原先處理戰鬥的原始方法完全一樣。
它對比每對單位，看看它們是否在同一位置。

不同之處是，我們不必再互相比較戰場上*所有的*單位——只與那些近在一個格子中的相比較。
這就是優化的核心。

<aside name="nested">

簡單分析一下，似乎我們讓性能*更糟*了。
我們從對單位的雙重循環變成了對格子內單位的*三重*循環。
這裏的技巧是內部循環現在只在很少的單位上運行，這足夠抵消在格子上的外部循環的代價。

但是，這依賴於我們格子的粒度。如果它們太小，外部循環確實會造成影響。

</aside>

### 衝鋒陷陣

我們解決了性能問題，但同時製造了新問題。
單位現在陷在它的格子中。
如果將單位移出了包含它的格子，格子中的單位就再也看不到它了，但其他單位也看不到它。
我們的戰場有點*過度*劃分了。

爲了解決這點，需要在每次單位移動時都做些工作。
如果它跨越了格子的邊界，我們需要將它從原來的格子中刪除，添加到新的格子中。
首先，我們給`Unit`添加一個改變位置的方法：

^code unit-move

顯而易見，AI代碼可以調用它來控制電腦的單位，玩家也可以輸入代碼調用它來控制玩家的單位。
它做的只是交換格子的控制權，之後：

^code grid-move

這塊代碼很長但也很直觀。
第一步檢查我們是否穿越了格子的邊界。
如果沒有，需要做的事情就是更新單位的位置，搞定。

如果單位*已經*離開了現在的格子，我們從格子的鏈表中移除它，然後再添加到網格中。
就像添加一個新單位，它會插入新格子的鏈表中。

這就是爲什麼我們使用雙向鏈表——我們可以通過設置一些指針飛快地添加和刪除單位。
每幀都有很多單位移動時，這就很重要了。

### 短兵相接

這看起來很簡單，但我們某種程度上作弊了。
在我展示的例子中，單位在它們有*完全相同的*位置時才進行交互。
西洋棋和國際象棋中這是真的，但是對於更加實際的遊戲就不那麼準確了。
它們通常需要將攻擊*距離*引入考慮。

這個模式仍然可以好好工作，與檢查位置匹配不同，我們這樣做：

^code handle-distance

當範圍被牽扯進來，需要考慮一個邊界情況：
在不同網格的單位也許仍然足夠接近，可以交互。

<img src="images/spatial-partition-adjacent.png" alt="兩個在相鄰網格的對象近得足以相互交互。" />

這裏，B在A的攻擊半徑內，即使中心點在不同的網格。
爲了處理這種情況，我們不僅需要比較同一網格的單位，同時需要比較鄰近網格的對象。
爲了達到這點，首先我們讓內層循環擺脫`handleCell()`：

^code handle-unit

現在有函數接受一個單位和一列表的其他單位看看有沒有碰撞。
讓`handleCell()`使這個函數：

^code handle-cell-unit

注意我們同樣傳入了網格的座標，而不僅僅是對象列表。
現在，這也許和前面的例子沒有什麼區別，但是我們會稍微擴展一下：

^code handle-neighbor

<span name="neighbor"></span>

這些新增`handleCell()`調用在八個鄰近格子中的四個格子中尋找這個單位是否與它們有任何對抗。
如果任何鄰近格子的單位離邊緣近到單位的攻擊半徑內，就找到碰撞了。

<aside name="neighbor">

有單位的格子是`U`，它查找的鄰近格子是`X`。

<img src="images/spatial-partition-neighbors.png" width="240" alt="八個內鄰格子，其中四個被標亮了。" />

</aside>

我們只查詢*一半*的近鄰格子，這原因和之前是一樣的：內層循環從當前單位*之後*的單位開始——避免每對單位比較兩次。
考慮如果我們檢查全部八個近鄰格子會發生什麼。

假設我們有兩個在鄰近格子的單位近到可以互相攻擊，就像前一個例子。
這是我們檢查全部8個格子會發生的事情：

1. 當找誰打了A時，我們檢查它的右邊找到了B。所以記錄一次A和B之間的攻擊。
2. 當找誰打了B時，我們檢查它的*左邊*找到了A。所以記錄*第二次*A和B之間的攻擊。

只檢查一半的近鄰格子修復了這點。檢查*哪一*半倒無關緊要。

我們還需要考慮另外的邊界情況。
這裏，我們假設最大攻擊距離小於一個格子。
如果我們有較小的小格子和較長的攻擊距離，我們也許需要掃描幾行外的近鄰格子。

## 設計決策

空間劃分的優秀數據結構相對較少，可以一一列舉進行介紹。
但是，我試圖根據它們的本質特性來組織。
我期望當你學習四叉樹和二分空間查找（BSPs）之類時，
可以幫助你理解它們是*如何*工作，*爲什麼* 工作，以幫你選擇。

### 劃分是層次的還是平面的？

<span name="couple"></span>

我們的網格例子將空間劃分成平面格子的集合。
相反，層次空間劃分將空間分成幾個區域。
然後，如果其中一個區域還包含多個對象，再劃分它。
這個過程遞歸進行，直到每個區域都有少於最大數量的對象在其中。

<aside name="couple">

它們通常分爲2,4,8塊——程序員很熟悉這些數值。

</aside>

* **如果是平面劃分：**

    <span name="simpler"></span>

    * *更簡單。*
      平面數據結構更容易想到也更容易實現。

        <aside name="simpler">

        我在每章中都提到了這個設計要點，這是有理由的。儘可能使用簡單的選項。
        大多數軟件工程都是與複雜度做鬥爭。

        </aside>

    * *內存使用量確定。*
      由於添加新對象不需要添加新劃分，空間分區的內存使用量通常在之前就可以確定。

    * *在對象改變位置時更新得更快。*
      當對象移動，數據結構需要更新，找到它的新位置。
      使用層次空間分區，可能需要在多層間調整層次結構。

* **如果是層次性的：**

    * *能更有效率地處理空的區域。*
      考慮之前的例子，如果戰場的一邊是空的。
      我們需要分配一堆空白格子，這些格子浪費內存，每幀還要遍歷它們。

        由於層次空間分區不再分割空區域，大的空區域保存在單個劃分上。不需要遍歷很多小空間，那裏只有一個大的。

    * *它處理密集空間更有效率。*
      這是硬幣的另一面：如果你有一堆對象堆在一起，無層次的劃分很沒有效率。
      你最終將所有對象都劃分到了一起，就跟沒有劃分一樣。
      層次空間分區會自適應地劃成小塊，讓你同時只需考慮少數對象。

### 劃分依賴於對象集合嗎？

在示例代碼中，網格空間大小事先被固定了，我們在格子裏追蹤單位。
另外的劃分策略是自適應的——它們根據現有的對象集合在世界中的位置劃分邊界。

目標是*均勻地*劃分，每個區域擁有相同的單位數量，以獲得最好性能。
考慮網格的例子，如果所有的單位都擠在戰場的一個角落裏。
它們都會在同一格子中，找尋單位間攻擊的代碼退化爲原來的*O(n&sup2;)* 問題。

* **如果劃分與對象無關：**

     * *對象可以增量添加。*
       添加對象意味着找到正確的劃分然後放入，這點可以一次性完成，沒有任何性能問題。

       <span name="sort"></span>

     * *對象移動得更快。*
       通過固定的劃分，移動單位意味着從格子移除然後添加到另一個。
       如果劃分它們的邊界跟着集合而改變，那麼移動對象會引起邊界移動，導致很多其他對象也要移到其他劃分。

         <aside name="sort">

         這可與如紅黑樹或AVL樹這樣的二叉搜索樹相類比：
         當你添加事物時，你也許最終需要重排樹，並重排一堆節點。

         </aside>

     * *劃分也許不均勻。*
       當然，固定的缺點就是對劃分缺少控制。如果對象擠在一起，你就在空區域上浪費了內存，這會造成更糟的性能。


* **如果劃分適應對象集合：**

    像BSPs和k-d樹這樣的空間劃分切分世界，讓每部分都包含接近相同數目的對象。
    爲了做到這點，劃分邊界時，你需要計算每邊各有多少對象。
    層次包圍盒是另外一種爲特定集合對象優化的空間分區。

    * *你可以保證劃分是平衡的。*
      這不僅提供了優良的性能表現，還提供了*穩定*的性能表現：
      如果每個區域的對象數量保持一致，你可以保證遊戲世界中的所有查詢都會消耗同樣的時間。
      一旦你需要固定幀率，這種一致性也許比性能本身更重要。

    * *一次性劃分一組對象更加有效率。*
      當對象*集合*影響了邊界的位置，最好在劃分前將所有對象放在前面。
      這就是爲什麼美術和地理更多地使用這種劃分。

* **如果劃分與對象無關，但*層次*與對象相關：**

    <span name="quad"></span>

    有一種空間分區需要特殊注意，因爲它擁有固定分區和適應分區兩者的優點：四叉樹。

    <aside name="quad">

    四叉樹劃分二維空間。它的三維實現是*八叉樹*，獲取“空間”，分割爲8個*正方體*。
    除了有額外的維度，它和平面劃分一樣工作。

    </aside>

    四叉樹開始時將整個空間視爲單一的劃分。
    如果空間中對象數目超過了臨界值，它將其切爲四小塊。
    這些塊的*邊界*是確定的：它們總是將空間一切爲二。

    然後，對於四個區域中的每一個，我們遞歸地做相同的事情，直到每個區域都有較少數目的對象在其中。
    由於我們遞歸地分割有較多對象的區域，這種劃分適應了對象集合，但是劃分本身沒有*移動*。

    你可以在這裏從左向右看到分區的過程：

    <img src="images/spatial-partition-quadtree.png" alt="一個四叉樹" />

    * *對象可以增量增加。*
      添加新對象意味着找到並添加到正確的區域。
      如果區域中的對象數目超過了最大限度，就劃分區域。
      區域中的其他對象也劃分到新的小區域中。這需要一些小小的工作，但是工作總量是*固定的*：
      你需要移動的對象數目總是少於數目臨界值。添加對象從來不會引發超過一次劃分。

        刪除對象也同樣簡單。
        你從它的格子中移除對象，如果它的父格子中的計數少於臨界值，你可以合併這些子分區。

    * *移動對象很快。*
      當然，如上所述，“移動”對象只是添加和移除，兩者在四叉樹中都很快。

    * *分區是平衡的。*
      由於任何給定的區域的對象數目都少於最大的對象數量，哪怕對象都堆在一起，你也不會有包含太多對象的分區。

### 對象只存儲在分區中嗎？

你可將空間分區作爲在遊戲中存儲對象的*唯一*地方，或者將其作爲更快查找的二級緩存，使用另一個集合包含對象。

* **如果它是對象唯一存儲的地方：**

    * *這避免了內存開銷和兩個集合帶來的複雜度。*
      當然，存儲對象一遍總比存兩遍來的輕鬆。
      同樣，如果你有兩個集合，你需要保證它們同步。
      每當添加或刪除對象，都得從兩者中添加或刪除對象。

* **如果其他集合保存對象：**

    * *遍歷所有的對象更快。*
      如果所有對象都是“活的”，而且它們需要做些處理，也許會發現你需要頻繁拜訪每個對象而並不在乎它的位置。
      想想看，早先的例子中，大多數格子都是空的。訪問那些空的格子是對時間的浪費。

        存儲對象的第二集合給了你直接遍歷對象的方法。
        你有兩個數據結構，每種爲各種的用況優化。

## 參見

* 在這裏，我試圖不討論特定的空間分區結構細節來保證這章的高層概況性（而且節約篇幅！），
  但你的下一步應該是學習一下常見的結構。儘管名字很恐怖，但它們都令人驚訝地直觀。常見的有：

    * [Grid](http://en.wikipedia.org/wiki/Grid_(spatial_index))
    * [Quadtree](http://en.wikipedia.org/wiki/Quad_tree)
    * [BSP](http://en.wikipedia.org/wiki/Binary_space_partitioning)
    * [k-d tree](http://en.wikipedia.org/wiki/Kd-tree)
    * [Bounding volume hierarchy](http://en.wikipedia.org/wiki/Bounding_volume_hierarchy)

* 每種空間分區數據結構基本上都是將一維數據結構擴展成更高維度的數據結構。
  知道它的相互關係有助於分辨它是不是問題的好解答：

    * 網格是連續的[桶排序](http://en.wikipedia.org/wiki/Bucket_sort)。
    * BSPs，k-d trees和包圍盒是[線性搜索樹](http://en.wikipedia.org/wiki/Binary_search_tree)。
    * 四叉樹和八叉樹是[多叉樹](http://en.wikipedia.org/wiki/Trie)。
