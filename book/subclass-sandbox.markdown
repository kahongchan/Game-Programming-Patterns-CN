^title 子類沙箱 Subclass Sandbox
^section Behavioral Patterns

## 意圖

*用一系列由基類提供的操作定義子類中的行爲。*

## 動機

每個孩子都夢想過變成超級英雄，但是不幸的是，高能射線在地球上很短缺。
遊戲是讓你扮演超級英雄最簡單的方法。
因爲我們的遊戲設計者從來沒有學會說“不”，*我們的*超級英雄遊戲中有成百上千種不同的超級能力可供選擇。

<span name="lots"></span>

我們的計劃是創建一個`Superpower`基類。然後由它派生出各種超級能力的實現類。
我們在程序員隊伍中分發設計文檔，然後開始編程。
當我們完成時，我們就會有上百種超級能力類。

<aside name="lots">

當你發現像這個例子一樣有*很多*子類時，那通常意味着數據驅動的方式更好。
不再用*代碼*定義不同的能力，用*數據*吧。

像<a class="pattern" href="type-object.html">類型對象</a>，<a class="pattern" href="bytecode.html">字節碼</a>，和<a class="gof-pattern" href="http://en.wikipedia.org/wiki/Interpreter_pattern">解釋器</a>模式都能幫忙。

</aside>

我們想讓玩家處於擁有無限可能的世界中。無論他們在孩童時想象過什麼能力，我們都要在遊戲中展現。
這就意味着這些超能力子類需要做任何事情：
播放聲音，產生視覺刺激，與AI交互，創建和銷燬其他遊戲實體，與物理打交道。沒有哪處代碼是它們不會接觸的。

假設我們讓團隊信馬由繮地寫超能力類。會發生什麼？

* *會有很多冗餘代碼。*
  當超能力種類繁多，我們可以預期有很多重疊。
  很多超能力都會用相同的方式產生視覺效果並播放聲音。
  當你坐下來看看，冷凍光線，熱能光線，芥末醬光線都很相似。
  如果人們實現這些的時候沒有協同，那就會有很多冗餘的代碼和重複勞動。

* *遊戲引擎中的每一部分都會與這些類耦合。*
  沒有深入瞭解的話，任何人都能寫出直接調用子系統的代碼，但子系統從來沒打算直接與超能力類綁定。
  就算渲染系統被好好組織成多個層次，只有一個能被外部的圖形引擎使用，
  我們可以打賭，最終超能力代碼會與每一個接觸。

* *當外部代碼需要改變時，一些隨機超能力代碼有很大機率會損壞。*
  一旦我們有了不同的超能力類綁定到遊戲引擎的多個部分，改變那些部分必然影響超能力類。
  這可不合理，因爲圖形，音頻，UI程序員很可能不想*也*成爲玩法程序員。

* *很難定義所有超能力遵守的不變量。*
  假設我們想保證超能力播放的所有音頻都有正確的順序和優先級。
  如果我們的幾百個類都直接調用音頻引擎，就沒什麼好辦法來完成這點。

我們要的是給每個實現超能力的玩法程序員一系列可使用的基本單元。
你想要播放聲音？這是你的`playSound()`函數。
你想要粒子效果？這是你的`spawnParticles()`函數。
我們保證了這些操作覆蓋了你要做的事情，所以你不需要`#include`隨機的頭文件，干擾到代碼庫的其他部分。

我們實現的方法是通過定義這些操作爲`Superpower`*基類*的*protected方法*。
將它們放在基類給了每個子類直接便捷的途徑獲取方法。
讓它們成爲protected（很可能不是虛方法）方法暗示了它們存在就是爲了被子類*調用*。

一旦有了這些東西來使用，我們需要一個地方使用他們。
爲了做到這點，我們定義*沙箱方法*，這是子類必須實現的抽象的protected方法。
有了這些，要實現一種新的能力，你需要：

1. 創建從`Superpower`繼承的新類。
2. 重載沙箱方法`activate()`。
3. 通過調用`Superpower`提供的protected方法實現主體。

我們現在可以使用這些高層次的操作來解決冗餘代碼問題了。
當我們看到代碼在多個子類間重複，我們總可以將其打包到`Superpower`中，作爲它們都可以使用的新操作。

我們通過將耦合約束到一個地方解決了耦合問題。
`Superpower`最終與不同的系統耦合，但是繼承它的幾百個類不會。
相反，它們*只*耦合基類。
當遊戲系統的某部分改變時，修改`Superpower`也許是必須的，但是衆多的子類不需要修改。

<span name="wide"></span>

這個模式帶來淺層但是廣泛的類層次。
你的繼承鏈不*深*，但是有*很多*類與`Superpower`掛鉤。
通過使用有很多直接子類的基類，我們在代碼庫中創造了一個支撐點。
我們投入到`Superpower`的時間和愛可以讓遊戲中衆多類獲益。

<aside name="wide">

最近，你會發現很多人批評面嚮對象語言中的繼承。
繼承*是*有問題——在代碼庫中沒有比父類子類之間的耦合更深的了——但我發現*扁平的*繼承樹比起*深的*繼承樹更好處理。

</aside>

## 模式

**基類**定義抽象的**沙箱方法**和幾個**提供的操作**。
將操作標爲protected，表明它們只爲子類所使用。
每個推導出的**沙箱子類**用提供的操作實現了沙箱函數。

## 何時使用

子類沙箱模式是潛伏在代碼庫中簡單常用的模式，哪怕是在遊戲之外的地方亦有應用。
如果你有一個非虛的protected方法，你可能已經在用類似的東西了。
沙箱方法在以下情況適用：

* 你有一個能推導很多子類的基類。

* 基類可以提供子類需要的所有操作。

* 在子類中有行爲重複，你想要更容易地在它們間分享代碼。

* 你想要最小化子類和程序的其他部分的耦合。

## 記住

“繼承”近來在很多編程圈子爲人詬病，原因之一是基類趨向於增加越來越多的代碼
這個模式特別容易染上這個毛病。

由於子類通過基類接觸遊戲的剩餘部分，基類最後和子類需要的*每個*系統耦合。
當然，子類也緊密地與基類相綁定。這種蛛網耦合讓你很難在不破壞什麼的情況下改變基類——你得到了（脆弱的基類問題）[brittle base class problem][]。

硬幣的另一面是由於你耦合的大部分都被推到了基類，子類現在與世界的其他部分分離。
理想的情況下，你大多數的行爲都在子類中。這意味着你的代碼庫大部分是孤立的，很容易管理。

如果你發現這個模式正把你的基類變成一鍋代碼糊糊，
考慮將它提供的一些操作放入分離的類中，
這樣基類可以分散它的責任。<a class="pattern" href="component.html">組件</a>模式可以在這裏幫上忙。

[brittle base class problem]: http://en.wikipedia.org/wiki/Fragile_base_class

## 示例代碼

因爲這個模式太簡單了，示例代碼中沒有太多東西。
這不是說它沒用——這個模式關鍵在於“意圖”，而不是它實現的複雜度。

我們從`Superpower`基類開始：

^code 1

`activate()`方法是沙箱方法。由於它是抽象虛函數，子類*必須*重載它。
這讓那些需要創建子類的人知道要做哪些工作。

其他的protected函數`move()`，`playSound()`，和`spawnParticles()`都是提供的操作。
它們是子類在實現`activate()`時要調用的。

在這個例子中，我們沒有實現提供的操作，但真正的遊戲在那裏有真正的代碼。
那些代碼中，`Superpower`與遊戲中其他部分的耦合——`move()`也許調用物理代碼，`playSound()`會與音頻引擎交互，等等。
由於這都在基類的*實現*中，保證了耦合封閉在`Superpower`中。

好了，拿出我們的放射蜘蛛，創建個能力。像這樣：

<span name="jump"></span>

^code 2

<aside name="jump">

好吧，也許*跳躍*不是*超級能力*，但我在這裏講的是基礎知識。

</aside>

這種能力將超級英雄射向天空，播放合適的聲音，揚起塵土。
如果所有的超能力都這樣簡單——只是聲音，粒子效果，動作的組合——那麼就根本不需要這個模式了。
相反，`Superpower`有內置的`activate()`能獲取聲音ID，粒子類型和運動的字段。
但是這隻在所有能力運行方式相同，只在數據上不同時纔可行。讓我們精細一些：

^code 3

這裏我們增加了些方法獲取英雄的位置。我們的`SkyLaunch`現在可以使用它們了：

^code 4

<span name="data"></span>
由於我們現在可以訪問狀態，沙箱方法可以做有用有趣的控制流了。
這還需要幾個簡單的`if`聲明，
但你可以做任何你想做的東西。
使用包含任意代碼的成熟沙箱方法，天高任鳥飛了。

<aside name="data">

早先，我建議以數據驅動的方式建立超能力。
這裏是你可能*不*想那麼做的原因之一。
如果你的行爲複雜而使用命令式風格，它更難在數據中定義。

</aside>

## 設計決策

如你所見，子類沙箱是一個“軟”模式。它表述了一個基本思路，但是沒有很多細節機制。
這意味着每次使用都面臨着一些有趣的選擇。這裏是一些需要思考的問題。

### 應該提供什麼操作？

這是最大的問題。這深深影響了模式感覺上和實際上有多好。
在一個極端，基類幾乎不提供*任何*操作。只有一個沙箱方法。
爲了實現功能，總是需要調用基類外部的系統。如果你這樣做，很難說你在使用這個模式。

<span name="include"></span>

另一個極端，基類提供了*所有*子類也許需要的操作。
子類*只*與基類耦合，不調用任何外部系統的東西。

<aside name="include">

具體來說，這意味着每個子類的源文件只需要`#include`它的基類頭文件。

</aside>

在這兩個極端之間，操作由基類提供還是向外部直接調用有很大的操作餘地。
你提供的操作越多，外部系統與子類耦合越少，但是與基類耦合*越多*。
從子類中移除了耦合是通過將耦合推給基類完成的。

如果你有一堆與外部系統耦合的子類的話，這很好。
通過將耦合移到提供的操作中，你將其移動到了一個地方：基類。但是你越這麼做，基類就越大越難管理。

所以分界線在哪裏？這裏是一些首要原則：

* 如果提供的操作只被一個或幾個子類使用，將操作加入基類獲益不會太多。
  你向基類添加了會影響所有事物的複雜性，但是隻有少數幾個類受益。

    讓該操作與其他提供的操作保持一致或許有價值，但讓使用操作的子類直接調用外部系統也許更簡單明瞭。

<span name="safe"></span>

* 當你調用遊戲中其他地方的方法，如果方法沒有修改狀態就有更少的干擾。
  它仍然製造耦合，但是這是“安全的”耦合，因爲它沒有破壞遊戲中的任何東西。

    <aside name="safe">

    “安全的”在這裏打了引號是因爲嚴格來說，接觸數據也能造成問題。
    如果你的遊戲是多線程的，讀取的數據可能正在被修改。如果你不小心，就會讀入錯誤的數據。

    另一個不愉快的情況是，如果你的遊戲狀態是嚴格確定性的（很多在線遊戲爲了保持玩家同步都是這樣的）。
    接觸了遊戲同步狀態之外的東西會造成極糟的不確定性漏洞。

    </aside>

    另一方面，修改狀態的調用會和代碼庫的其他方面緊密綁定，你需要三思。打包他們成基類提供的操作是個好的候選項。

* 如果操作只是增加了向外部系統的轉發調用，那它就沒增加太多價值。那種情況下，也許直接調用外部系統的方法更簡單。

    但是，簡單的轉發也是有用的——那些方法接觸了基類不想直接暴露給子類的狀態。
    舉個例子，假設`Superpower`提供這個：

    ^code 5

    它只是轉發調用給`Superpower`中`soundEngine_`字段。
    但是，好處是將字段封裝在`Superpower`中，避免子類接觸。

### 方法應該直接提供，還是包在對象中提供？

這個模式的挑戰是基類中最終加入了很多方法。
你可以將一些方法移到其他類中來緩和。基類通過返回對象提供方法。

舉個例子，爲了讓超能力播放聲音，我們可以直接將它們加到`Superpower`中：

^code 6

但是如果`Superpower`已經很龐雜了，我們也許想要避免這樣。
取而代之的是創建`SoundPlayer`類暴露該函數：

^code 7

`Superpower`提供了對其的接觸：

^code 8

將提供的操作分流到輔助類可以爲你做一些事情：

* *減少了基類中的方法。*
  在這裏的例子中，將三個方法變成了一個簡單的獲取函數。

* *在輔助類中的代碼通常更好管理。*
  像`Superpower`的核心基類，不管意圖如何好，它被太多的類依賴而很難改變。
  通過將函數移到耦合較少的次要類，代碼變得更容易被使用而不破壞任何東西。

* *減少了基類和其他系統的耦合度。*
  當`playSound()`方法直接在`Superpower`時，基類與`SoundId`以及其他涉及的音頻代碼直接綁定。
  將它移動到`SoundPlayer`中，減少了`Superpower`與`SoundPlayer`類的耦合，這就封裝了它其他的依賴。

### 基類如何獲得它需要的狀態？

你的基類經常需要將對子類隱藏的數據封裝起來。
在第一個例子中，`Superpower`類提供了`spawnParticles()`方法。
如果方法的實現需要一些粒子系統對象，怎麼獲得呢？

* **將它傳給基類構造器：**

    最簡單的解決方案是讓基類將其作爲構造器變量：

    ^code pass-to-ctor-base

    這安全地保證了每個超能力在構造時能得到粒子系統。但讓我們看看子類：

    ^code pass-to-ctor-sub

    我們在這兒看到了問題。每個子類都需要構造器調用基類構造器並傳遞變量。這讓子類接觸了我們不想要它知道的狀態。

    這也造成了維護的負擔。如果我們後續向基類添加了狀態，每個子類都需要修改並傳遞這個狀態。

* **使用兩階初始化：**

    爲了避免通過構造器傳遞所有東西，我們可以將初始化劃分爲兩個部分。
    構造器不接受任何參數，只是創建對象。然後，我們調用定義在基類的分離方法傳入必要的數據：

    ^code 9

    注意我們沒有爲`SkyLaunch`的構造器傳入任何東西，它與`Superpower`中想要保持私有的任何東西都不耦合。
    這種方法的問題在於，你要保證永遠記得調用`init()`，如果忘了，你會獲得處於半完成的，無法運行的超能力。

    你可以將整個過程封裝到一個函數中來修復這一點，就像這樣：

    <span name="friend"></span>

    ^code 10

    <aside name="friend">

    使用一點像私有構造器和友類的技巧，你可以保證`createSkylaunch()`函數是唯一能夠創建能力的函數。
    這樣，你不會忘記任何初始化步驟。

    </aside>

* **讓狀態靜態化：**

    在先前的例子中，我們用粒子系統初始化每一個`Superpower`*實例*。
    在每個能力都需要自己獨特的狀態時這是有意義的。但是如果粒子系統是<a class="pattern" href="singleton.html">單例</a>，那麼每個能力都會分享相同的狀態。

    如果是這樣，我們可以讓狀態是基類私有而<span name="singleton">*靜態*</span>的。
    遊戲仍然要保證初始化狀態，但是它只需要爲整個遊戲初始化`Superpower`*類*一遍，而不是爲每個實例初始化一遍。

    <aside name="singleton">

    記住單例仍然有很多問題。你在很多對象中分享了狀態（所有的`Superpower`實例）。
    粒子系統被封裝了，因此它不是全局*可見的*，這很好，但它們都訪問同一對象，這讓分析更加困難了。

    </aside>

    ^code 11

    注意這裏的`init()`和`particles_`都是靜態的。
    只要遊戲早先調用過一次`Superpower::init()`，每種能力都能接觸粒子系統。
    同時，可以調用正確的推導類構造器來自由創建`Superpower`實例。

    更棒的是，現在`particles_`是*靜態*變量，
    我們不需要在每個`Superpower`中存儲它，這樣我們的類佔據的內存更少了。

* **使用服務定位器：**

    前一選項中，外部代碼要在基類請求前壓入基類需要的全部狀態。
    初始化的責任交給了周圍的代碼。另一選項是讓基類拉取它需要的狀態。
    而做到這點的一種實現方法是使用<a class="pattern" href="service-locator.html">服務定位器</a>模式：

    ^code 12

    這兒，`spawnParticles()`需要粒子系統，不是外部系統*給*它，而是它自己從服務定位器中拿了一個。

## 參見

* 當你使用<a class="pattern" href="update-method.html">更新模式</a>時，你的更新函數通常也是沙箱方法。

* 這個模式與<a class="gof-pattern" href="http://en.wikipedia.org/wiki/Template_method_pattern">模板方法</a>正相反。
  兩種模式中，都使用一系列受限操作實現方法。
  使用子類沙箱時，方法在推導類中，受限操作在基類中。
  使用模板方法時，*基類* 有方法，而受限操作在*推導*類中。

* 你也可以認爲這個模式是<a class="gof-pattern" href="http://en.wikipedia.org/wiki/Facade_Pattern">外觀</a>模式的變形。
  外觀模式將一系列不同系統藏在簡化的API後。使用子類沙箱，基類起到了在子類前隱藏整個遊戲引擎的作用。
