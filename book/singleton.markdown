^title 單例模式 Singleton
^section Design Patterns Revisited

這個章節不同尋常。
其他章節展示如何使用某個設計模式。
這個章節展示如何*避免*使用某個設計模式。

<span name="instance"></span>
儘管它的意圖是好的，GoF描述的<a class="gof-pattern" href="http://c2.com/cgi/wiki?SingletonPattern">單例模式</a>通常弊大於利。
他們強調應該謹慎使用這個模式，但在遊戲業界的口口相傳中，這一提示經常被無視了。

就像其他模式一樣，在不合適的地方使用單例模式就好像用夾板處理子彈傷口。
由於它被濫用得太嚴重了，這章的大部分都在講如何*迴避*單例模式，
但首先，讓我們看看模式本身。

<aside name="instance">

當業界從C語言遷移到面向對象的語言，他們遇到的首個問題是“如何訪問實例？”
他們知道有要調用的方法，但是找不到實例提供這個方法。
單例（換言之，全局化）是一條簡單的解決方案。

</aside>

## 單例模式

*設計模式* 像這樣描述單例模式：

> 保證一個類只有一個實例，並且提供了訪問該實例的全局訪問點。

我們從“並且”那裏將句子分爲兩部分，分別進行考慮。

### 保證一個類只有一個實例

有時候，如果類存在多個實例就不能正確的運行。
通常發生在類與保存全局狀態的外部系統互動時。

考慮封裝文件系統的API類。
因爲文件操作需要一段時間完成，所以類使用異步操作。
這就意味着可以同時運行多個操作，必須讓它們相互協調。
如果一個操作創建文件，另一個操作刪除同一文件，封裝器類需要同時考慮，保證它們沒有相互妨礙。

爲了實現這點，對我們封裝器類的調用必須接觸之前的每個操作。
如果用戶可以自由地創建類的實例，這個實例就無法知道另一實例之前的操作。
而單例模式提供的構建類的方式，在編譯時保證類只有單一實例。

### 提供了訪問該實例的全局訪問點

遊戲中的不同系統都會使用文件系統封裝類：日誌，內容加載，遊戲狀態保存，等等。
如果這些系統不能創建文件系統封裝類的實例，它們如何訪問該實例呢？

單例爲這點也提供瞭解決方案。
除了創建單一實例以外，它也提供了一種獲得它的全局方法。
使用這種範式，無論何處何人都可以訪問實例。
綜合起來，經典的實現方案如下：

^code 1

靜態的`instance_`成員保存了一個類的實例，
私有的構造器保證了它是*唯一*的。
公開的靜態方法`instance()`讓任何地方的代碼都能訪問實例。
在首次被請求時，它同樣負責惰性實例化該單例。

現代的實現方案看起來是這樣的：

^code local-static

<span name="thread"></span>
哪怕是在多線程情況下，C++11標準也保證了本地靜態變量只會初始化一次，
因此，假設你有一個現代C++編譯器，這段代碼是線程安全的，而前面的那個例子不是。

<aside name="thread">

當然，單例類本身的線程安全是個不同的問題！這裏只保證了它的*初始化*沒問題。

</aside>

## 爲什麼我們使用它

看起來已有成效。
文件系統封裝類在任何需要的地方都可用，而無需笨重地到處傳遞。
類本身巧妙地保證了我們不會實例化多個實例而搞砸。它還具有很多其他的優良性質：

*   **如果沒人用，就不必創建實例。**
    節約內存和CPU循環總是好的。
    由於單例只在第一次被請求時實例化，如果遊戲永遠不請求，那麼它不會被實例化。

*   **它在運行時實例化。**
    通常的替代方案是使用含有靜態成員變量的類。
    我喜歡簡單的解決方案，因此我儘可能使用靜態類而不是單例，但是靜態成員有個限制：自動初始化。
    編譯器在`main()`運行前初始化靜態變量。
    這就意味着不能使用在程序加載時才獲取的信息（舉個例子，從文件加載的配置）。
    這也意味着它們的相互依賴是不可靠的——編譯器可不保證以什麼樣的順序初始化靜態變量。

    惰性初始化解決了以上兩個問題。
    單例會盡可能晚地初始化，所以那時它需要的所有信息都應該可用了。
    只要沒有環狀依賴，一個單例在初始化它自己的時甚至可以引用另一個單例。

*   **可繼承單例。**
    這是個很有用但通常被忽視的能力。
    假設我們需要跨平臺的文件系統封裝類。
    爲了達到這一點，我們需要它變成文件系統抽象出來的接口，而子類爲每個平臺實現接口。
    這是基類：

    ^code 2

    然後爲一堆平臺定義子類：

    ^code derived-file-systems

    下一步，我們把`FileSystem`變成單例：

    ^code 3

    靈巧之處在於如何創建實例：

    ^code 4

    通過一個簡單的編譯器轉換，我們把文件系統包裝類綁定到合適的具體類型上。
    整個代碼庫都可以使用`FileSystem::instance()`接觸到文件系統，而無需和任何平臺相關的代碼耦合。耦合發生在爲特定平臺寫的`FileSystem`類實現文件中。

大多數人解決問題到這個程度就已經夠了。
我們得到了一個文件系統封裝類。
它工作可靠，它全局有效，只要請求就能獲取。
是時候提交代碼，開懷暢飲了。

## 爲什麼我們後悔使用它

短期來看，單例模式是相對良性的。
就像其他設計決策一樣，我們需要從長期考慮。
這裏是一旦我們將一些不必要的單例寫進代碼，會給自己帶來的麻煩：

### 它是一個全局變量

當遊戲還是由幾個傢伙在車庫中完成時，榨乾硬件性能比象牙塔裏的軟件工程原則更重要。
C語言和彙編程序員前輩能毫無問題地使用全局變量和靜態變量，發佈好遊戲。
但隨着遊戲變得越來越大，越來越複雜，架構和管理開始變成瓶頸，
阻礙我們發佈遊戲的，除了硬件限制，還有*生產力*限制。

所以我們遷移到了像C++這樣的語言，
開始將一些從軟件工程師前輩那裏學到的智慧應用於實際。
其中一課是全局變量有害的諸多原因：

<span name="pure"></span>

*   **理解代碼更加困難。**
    假設我們在查找其他人所寫函數中的漏洞。
    如果函數沒有碰到任何全局狀態，腦子只需圍着函數轉，
    只需搞懂函數和傳給函數的變量。

    <aside name="pure">

    計算機科學家稱不接觸不修改全局狀態的函數爲“純”函數。
    純函數易於理解，易於編譯器優化，
    易於完成優雅的任務，比如記住緩存的情況並繼續上次調用。

    完全使用純函數是有難度的，但其好處足以引誘科學家創造像Haskell這樣*只*使用純函數的語言。

    </aside>

    現在考慮函數中間是個對`SomeClass::getSomeGlobalData()`的調用。爲了查明發生了什麼，得追蹤整個代碼庫來看看什麼修改了全局變量。你真的不需要討厭全局變量，直到你在凌晨三點使用`grep`搜索數百萬行代碼，搞清楚哪一個錯誤的調用將一個靜態變量設爲了錯誤的值。

*   **促進了耦合的發生。**
    新加入團隊的程序員也許不熟悉你們完美、可維護、鬆散耦合的遊戲架構，
    但還是剛剛獲得了第一個任務：在岩石撞擊地面時播放聲音。
    你我都知道這不需要將物理和*音頻*代碼耦合，但是他只想着把任務完成。
    不幸的是，我們的`AudioPlayer`是全局可見的。
    所以之後一個小小的`#include`，新隊員就打亂了整個精心設計的架構。

    如果不用全局實例實現音頻播放器，那麼哪怕他*確實*用`#include`包含了頭文件，他還是啥也做不了。
    這種阻礙給他發送了一個明確的信號，這兩個模塊不該接觸，他需要另闢蹊徑。*通過控制對實例的訪問，你控制了耦合。*

*   **對並行不友好。**
    那些在單核CPU上運行遊戲的日子已經遠去。
    哪怕完全不需要並行的優勢，現代的代碼至少也應考慮在多線程環境下*工作*。
    當我們將某些東西轉爲全局變量時，我們創建了一塊每個線程都能看到並訪問的內存，
    卻不知道其他線程是否正在使用那塊內存。
    這種方式帶來了死鎖，競爭狀態，以及其他很難解決的線程同步問題。

像這樣的問題足夠嚇阻我們聲明全局變量了，
同理單例模式也是一樣，但是那還沒有告訴我們*應該*如何設計遊戲。
怎樣不使用全局變量構建遊戲？

有幾個對這個問題的答案（這本書的大部分都*是*由答案構成），
但是它們並非顯而易見。
與此同時，我們得發佈遊戲。
單例模式看起來是萬能藥。
它被寫進了一本關於面向對象設計模式的書中，因此它*肯定*是個好的設計模式，對吧？
況且我們已經藉助它做了很多年軟件設計了。

不幸的是，它不是解藥，它是安慰劑。
如果瀏覽全局變量造成的問題列表，你會注意到單例模式解決不了其中任何一個。
因爲單例*確實是*全局狀態——它只是被封裝在一個類中。

### 它能在你只有一個問題的時候解決兩個

在GoF對單例模式的描述中，“並且”這個詞有點奇怪。
這個模式解決了一個問題還是兩個問題呢？如果我們只有其中一個問題呢？
保證實例是唯一存在的是很有用的，但是誰告訴我們要讓*每個人*都能接觸到它？
同樣，全局接觸很方便，但是必須禁止存在多個實例嗎？

這兩個問題中的後者，便利的訪問，幾乎是使用單例模式的全部原因。
想想日誌類。大部分模塊都能從記錄診斷日誌中獲益。
但是，如果將`Log`類的實例傳給每個需要這個方法的函數，那就混雜了產生的數據，模糊了代碼的意圖。

明顯的解決方案是讓`Log`類成爲單例。
每個函數都能從類那裏獲得一個實例。
但當我們這樣做時，我們無意地製造了一個奇怪的小約束。
突然之間，我們不再能創建多個日誌記錄者了。

起初，這不是一個問題。
我們記錄單獨的日誌文件，所以只需要一個實例。
然後，隨着開發週期的逐次循環，我們遇到了麻煩。
每個團隊的成員都使用日誌記錄各自的診斷信息，大量的日誌傾瀉在文件裏。
程序員需要翻過很多頁代碼來找到他關心的記錄。

<span name="worse"></span>
我們想將日誌分散到多個文件中來解決這點。
爲了達到這點，我們得爲遊戲的不同領域創造單獨的日誌記錄者：
網絡，UI，聲音，遊戲，玩法。
但是我們做不到。
`Log`類不再允許我們創建多個實例，而且調用的方式也保證了這一點：

    Log::instance().write("Some event.");

爲了讓`Log`類支持多個實例（就像它原來的那樣），
我們需要修改類和提及它的每一行代碼。
之前便利的訪問就不再那麼便利了。

<aside name="worse">

這可能更糟。想象一下你的`Log`類是在多個*遊戲*間共享的庫中。
現在，爲了改變設計，需要在多組人之間協調改變，
他們中的大多數既沒有時間，也沒有動機修復它。

</aside>

### 惰性初始化從你那裏剝奪了控制權

在擁有虛擬內存和軟性性能需求的PC裏，惰性初始化是一個小技巧。
遊戲則是另一種狀況。初始化系統需要消耗時間：分配內存，加載資源，等等。
如果初始化音頻系統消耗了幾百個毫秒，我們需要控制它何時發生。
如果在第一次聲音播放時惰性初始化它自己，這可能發生在遊戲的高潮部分，導致可見的掉幀和斷續的遊戲體驗。

<span name="fragment"></span>
同樣，遊戲通常需要嚴格管理在堆上分配的內存來避免碎片。
如果音頻系統在初始化時分配到了堆上，我們需要知道初始化在*何時*發生，
這樣我們可以控制內存待在堆的*哪裏*。

<aside name="fragment">

<a class="pattern" href="object-pool.html">對象池模式</a>一節中有內存碎片的其他細節。

</aside>

因爲這兩個原因，我見到的大多數遊戲都不使用惰性初始化。
相反，它們像這樣實現單例模式：

^code 5

這解決了惰性初始化問題，但是損失了幾個單例*確實*比原生的全局變量優良的特性。
靜態實例中，我們不能使用多態，在靜態初始化時，類也必須是可構建的。
我們也不能在不需要這個實例的時候，釋放實例所佔的內存。

<span name="static"></span>
與創建一個單例不同，這裏實際上是一個簡單的靜態類。
這並非壞事，但是如果你需要的是靜態類，爲什麼不完全擺脫`instance()`方法，
直接使用靜態函數呢？調用`Foo::bar()`比`Foo::instance().bar()`更簡單，
也更明確地表明你在處理靜態內存。

<aside name="static">

通常使用單例而不是靜態類的理由是，
如果你後來決定將靜態類改爲非靜態的，你需要修改每一個調用點。
理論上，用單例就不必那麼做，因爲你可以將實例傳來傳去，像普通的實例方法一樣使用。

實踐中，我從未見過這種情況。
每個人都在使用`Foo::instance().bar()`。
如果我們將Foo改成非單例，我們還是得修改每一個調用點。
鑑於此，我更喜歡簡單的類和簡單的調用語法。

</aside>

## 那該如何是好

如果我現在達到了目標，你在下次遇到問題使用單例模式之前就會三思而後行。
但是你還是有問題需要解決。你*應該*使用什麼工具呢？
這取決於你試圖做什麼，我有一些你可以考慮的選項，但是首先……

### 看看你是不是真正地需要類

我在遊戲中看到的很多單例類都是“管理器”——那些類存在的意義就是照顧其他對象。
我曾看到一些代碼庫中，幾乎*所有*類都有管理器：
怪物，怪物管理器，粒子，粒子管理器，聲音，聲音管理器，管理管理器的管理器。
有時候，它們被叫做“系統”或“引擎”，但是思路還是一樣的。

管理器類有時是有用的，但通常它們只是反映出作者對OOP的不熟悉。思考這兩個特製的類：

^code 8

也許這個例子有些蠢，但是我見過很多代碼，在剝離了外部的細節後是一樣的設計。
如果你看看這個代碼，`BulletManager`很自然應是一個單例。
無論如何，任何有`Bullet`的對象都需要管理，而你又需要多少個`BulletManager`實例呢？

事實上，這裏的答案是*零*。
這裏是我們如何爲管理類解決“單例”問題：

^code 9

好了。沒有管理器，也沒有問題。
糟糕設計的單例通常會“幫助”另一個類增加代碼。
如果可以，把所有的行爲都移到單例幫助的類中。
畢竟，OOP就是讓對象管理好自己。

但是在管理器之外，還有其他問題我們需要尋求單例模式幫助。
對於每種問題，都有一些後續方案可供參考。

### 將類限制爲單一的實例

<span name="wrapper"></span>
這是單例模式幫你解決的一個問題。
就像在文件系統的例子中那樣，保證類只有一個實例是很重要的。
但是，這不意味着我們需要提供對實例的*公衆*，*全局*訪問。
我們想要減少某部分代碼的公衆部分，甚至讓它在類中是私有的。
在這些情況下，提供一個全局接觸點消弱了整體架構。

<aside name="wrapper">

舉個例子，我們也許想把文件系統包在*另一*層抽象中。

</aside>

我們希望有種方式能保證同事只有一個實例而*無需*提供全局接觸點。
有好幾種方法能做到。這是其中之一：

<span name="assert"></span>

^code 6

這個類允許任何人構建它，如果你試圖構建超過一個實例，它會斷言並失敗。
只要正確的代碼首先創建了實例，那麼就保證了沒有其他代碼可以接觸實例或者創建自己的實例。
這個類保證滿足了它關注的單一實例，但是它沒有指定類該如何被使用。

<aside name="assert">

*斷言* 函數是一種向你的代碼中添加限制的方法。
當`assert()`被調用時，它計算傳入的表達式。
如果結果爲`true`，那麼什麼都不做，遊戲繼續。
如果結果爲`false`，它立刻停止遊戲。
在debug build時，這通常會啓動調試器，或至少打印失敗斷言所在的文件和行號。

`assert()`表示，
“我斷言這個總該是真的。如果不是，那就是漏洞，我想*立刻*停止並處理它。”
這使得你可以在代碼區域之間定義約束。
如果函數斷言它的某個參數不能爲`NULL`，那就是說，“我和調用者定下了協議：傳入的參數不會`NULL`。”

斷言幫助我們在遊戲發生預期以外的事時立刻追蹤漏洞，
而不是等到錯誤最終顯現在用戶可見的某些事物上。
它們是代碼中的柵欄，圍住漏洞，這樣漏洞就不能從製造它的代碼邊逃開。

</aside>

這個實現的缺點是隻在*運行時*檢查並阻止多重實例化。
單例模式正相反，通過類的自然結構，在編譯時就能確定實例是單一的。

### 爲了給實例提供方便的訪問方法

便利的訪問是我們使用單例的一個主要原因。
這讓我們在不同地方獲取需要的對象更加容易。
這種便利是需要付出代價的——在我們*不想*要對象的地方，也能輕易地使用。

通用原則是在能完成工作的同時，將變量寫得儘可能局部。
對象影響的範圍越小，在處理它時，我們需要放在腦子裏的東西就越少。
在我們拿起有*全局*範圍影響的單例對象前，先考慮考慮代碼中其他獲取對象的方式：

<span name="di"></span>

* **傳進來。**
    最簡單的解決辦法，通常也是最好的，把你需要的對象簡單地作爲參數傳給需要它的函數。
    在用其他更加繁雜的方法前，考慮一下這個解決方案。

    <aside name="di">

    有些人使用術語“依賴注入”來指代它。不是代碼*出來*調用某些全局量來確認依賴，
    而是依賴通過參數被*傳進*到需要它的代碼中去。
    其他人將“依賴注入”保留爲對代碼提供更復雜依賴的方法。

    </aside>

    考慮渲染對象的函數。爲了渲染，它需要接觸一個代表圖形設備的對象，管理渲染狀態。
    將其傳給所有渲染函數是很自然的，通常是用一個名字像`context`之類的參數。

    <span name="aop"></span>
    另一方面，有些對象不該在方法的參數列表中出現。
    舉個例子，處理AI的函數可能也需要寫日誌文件，但是日誌不是它的核心關注點。
    看到`Log`出現在它的參數列表中是很奇怪的事情，像這樣的情況，我們需要考慮其他的選項。

    <aside name="aop">

    像日誌這樣散佈在代碼庫各處的是“橫切關注點”(cross-cutting concern)。
    小心地處理橫切關注點是架構中的持久挑戰，特別是在靜態類型語言中。

    [面向切面編程](http://en.wikipedia.org/wiki/Aspect-oriented_programming)被設計出來應對它們。

    </aside>

* **從基類中獲得。**
    很多遊戲架構有淺層但是寬泛的繼承層次，通常只有一層深。
    舉個例子，你也許有`GameObject`基類，每個遊戲中的敵人或者對象都繼承它。
    使用這樣的架構，很大一部分遊戲代碼會存在於這些“子”推導類中。
    這就意味着這些類已經有了對同樣事物的相同獲取方法：它們的`GameObject`基類。
    我們可以利用這點：

    <span name="gameobject"></span>

    ^code 10

    這保證任何`GameObject`之外的代碼都不能接觸`Log`對象，但是每個派生的實體都確實能使用`getLog()`。
    這種使用protected函數，讓派生對象使用的模式，
    被涵蓋在<a class="pattern" href="subclass-sandbox.html">子類沙箱</a>這章中。

    <aside name="gameobject">

    這也引出了一個新問題，“`GameObject`是怎樣獲得`Log`實例的？”一個簡單的方案是，讓基類創建並擁有靜態實例。

    如果你不想要基類承擔這些，你可以提供一個初始化函數傳入`Log`實例，
    或使用<a class="pattern" href="service-locator.html">服務定位器</a>模式找到它。

    </aside>

* **從已經是全局的東西中獲取。**
    移除*所有*全局狀態的目標令人欽佩，但並不實際。
    大多數代碼庫仍有一些全局可用對象，比如一個代表了整個遊戲狀態的`Game`或`World`對象。

    我們可以讓現有的全局對象捎帶需要的東西，來減少全局變量類的數目。
    不讓`Log`，`FileSystem`和`AudioPlayer`都變成單例，而是這樣做：

    ^code 11

    <span name="demeter"></span>
    這樣，只有`Game`是全局可見的。
    函數可以通過它訪問其他系統。

    ^code 12

    <aside name="demeter">

    純粹主義者會聲稱這違反了Demeter法則。我則聲稱這比一大坨單例要好。

    </aside>

    如果，稍後，架構被改爲支持多個`Game`實例（可能是爲了流處理或者測試），
    `Log`，`FileSystem`，和`AudioPlayer`都不會被影響到——它們甚至不知道有什麼區別。
    缺陷是，當然，更多的代碼耦合到了`Game`中。
    如果一個類簡單地需要播放聲音，爲了訪問音頻播放器，上例中仍然需要它知道遊戲世界。

    我們通過混合方案解決這點。
    知道`Game`的代碼可以直接從它那裏訪問`AudioPlayer`。
    而不知道的代碼，我們用上面描述的其他選項來提供`AudioPlayer`。

* **從服務定位器中獲得。**
    目前爲止，我們假設全局類是具體的類，比如`Game`。
    另一種選項是定義一個類，存在的唯一目標就是爲對象提供全局訪問。
    這種常見的模式被稱爲<a class="pattern" href="service-locator.html">服務定位器</a>模式，有單獨講它的章節。

## 單例中還剩下什麼

剩下的問題，何處我們*應該*使用真實的單例模式？
說實話，我從來沒有在遊戲中使用全部的GoF模式。
爲了保證實例是單一的，我通常簡單地使用靜態類。
如果這無效，我使用靜態標識位，在運行時檢測是不是隻有一個實例被創建了。

書中還有一些其他章節也許能有所幫助。
<a class="pattern" href="subclass-sandbox.html">子類沙箱</a>模式通過分享狀態，
給實例以類的訪問權限而無需讓其全局可用。
<a class="pattern" href="service-locator.html">服務定位器</a>模式*確實*讓一個對象全局可用，
但它給了你如何設置對象的靈活性。
