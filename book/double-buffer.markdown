^title 雙緩衝模式 Double Buffer
^section Sequencing Patterns

## 意圖

*用序列的操作模擬瞬間或者同時發生的事情。*

## 動機

<span name="sequential"></span>
電腦具有強大的序列化處理能力。
它的力量來自於將大的任務分解爲小的步驟，這樣可以一步接一步的完成。
但是，通常用戶需要看到事情發生在瞬間或者讓多個任務同時進行。

<aside name="sequential">

使用線程和多核架構讓這種說法不那麼正確了，但哪怕使用多核，也只有一些操作可以同步運行。

</aside>

一個典型的例子，也是每個遊戲引擎都得掌控的問題，渲染。
當遊戲渲染玩家所見的世界時，它同時需要處理一堆東西——遠處的山，起伏的丘陵，樹木，每個都在各自的循環中處理。
如果在用戶*觀察*時增量做這些，連續世界的幻覺就會被打破。
場景必須快速流暢地更新，顯示一系列完整的幀，每幀都是立即出現的。

雙緩衝解決了這個問題，但是爲了理解其原理，讓我們首先的複習下計算機是如何顯示圖形的。

### 計算機圖形系統是如何工作的（概述）

<span name="scan"></span>
在電腦屏幕上顯示圖像是一次繪製一個像素點。
它從左到右掃描每行像素點，然後移動至下一行。
當抵達了右下角，它退回左上角重新開始。
它做得飛快——每秒六十次——因此我們的眼睛無法察覺。
對我們來說，這是一整張靜態的彩色像素——一張圖像。

<aside name="scan">

這個解釋是“簡化過的”。
如果你是底層軟件開發人員，跳過下一節吧。
你對這章的其餘部分已經瞭解得夠多了。
如果你不是，這部分的目標是給你足夠的背景知識，理解等下要討論的設計模式。

</aside>

你可以將整個過程想象爲軟管向屏幕噴灑像素。
獨特的像素從軟管的後面流入，然後在屏幕上噴灑，每次對一個像素塗一點顏色。
所以軟管怎麼知道哪種顏色要噴到哪裏？

<span name="color"></span>
在大多數電腦上，答案是從*幀緩衝*中獲知這些信息。
幀緩衝是內存中的色素數組，RAM中每兩個字節代表表示一個像素點的顏色。
當軟管向屏幕噴灑時，它從這個數組中讀取顏色值，每次一個字節。

<aside name="color">

在字節值和顏色之間的映射通常由系統的*像素格式*和*色深*來指定。
在今日多數遊戲主機上，每個像素都有32位，紅綠藍三個各佔八位，剩下的八位保留作其他用途。

</aside>

最終，爲了讓遊戲顯示在屏幕中，我們需要做的就是寫入這個數組。
我們瘋狂擺弄的圖形算法最終都到了這裏：設置幀緩衝中的字節值。
但這裏有個小問題。

早先，我說過計算機是順序處理的。
如果機器在運行一塊渲染代碼，我們不指望它同時還能做些別的什麼事。
這通常是沒啥問題，但是有些事*確實*在程序運行時發生。
其中一件是，當遊戲運行時，視頻輸出正在*不斷*從幀緩衝中讀取數據。
這可能會爲我們帶來問題。

假設我們要在屏幕上顯示一張笑臉。
程序在幀緩衝上開始循環，爲像素點塗色。
我們沒有意識到的是，在寫入的同時，視頻驅動正在讀取它。
當它掃描過已寫的像素時，笑臉開始浮現，但是之後它進入了未寫的部分，就將沒有寫的像素繪製到了屏幕上。結果就是*撕裂*，你在屏幕上看到了繪製到一半的圖像，這是可怕的視覺漏洞。

<span name="tearing"></span>

<img src="images/double-buffer-tearing.png" alt="描述了正在渲染的幀的一系列圖片。一個指針在像素上寫入，與此同時，另一個指針正在讀取。讀取的指針越過了寫入的指針，然後開始讀取未曾渲染的像素點。" />

<aside name="tearing">

顯卡設備讀取的緩衝幀正是我們繪製像素的那塊(Fig. 1)。
顯卡最終追上了渲染器，然後越過它，讀取了還沒有寫入的像素(Fig. 2)。
我們完成了繪製，但驅動沒有收到那些新像素。

結果(Fig. 4)是用戶只看到了一半的繪製結果。
我稱它爲“哭臉”，笑臉看上去下半部是撕裂的。

</aside>

這就是我們需要這個設計模式的原因。
程序一次渲染一個像素，但是顯示需要一次全部看到——在這幀中啥也沒有，下一幀笑臉全部出現。
雙緩衝解決了這個問題。我會用類比來解釋。

### 表演1，場景1

想象玩家正在觀看我們的表演。
在場景一結束而場景二開始時，我們需要改變舞臺設置。
如果讓場務在場景結束後進去拖動東西，場景的連貫性就被打破了。
我們可以減弱燈光（這是劇院實際上的做法），但是觀衆還是知道*有什麼*在進行，而我們想在場景間毫無跳躍地轉換。

<span name="stage"></span>
通過消耗一些地皮，我們想到了一個聰明的解決方案：建*兩個*舞臺，觀衆兩個都能看到。
每個有它自己的一組燈光。我們稱這些舞臺爲舞臺A和舞臺B。
場景一在舞臺A上。同時場務在處於黑暗之中的舞臺B佈置場景二。
當場景一完成後，將切斷場景A的燈光，打開場景B的燈光。觀衆看向新舞臺，場景二立即開始。

同時，場務到了黑咕隆咚的舞臺*A*，收拾了場景一然後佈置場景*三*。
一旦場景二結束，將燈光轉回舞臺A。
我們在整場表演中進行這樣的活動，使用黑暗的舞臺作爲佈置下一場景的工作區域。
每一次場景轉換，只是在兩個舞臺間切換燈光。
觀衆獲得了連續的體驗，場景轉換時沒有感到任何中斷。他們從來沒有見到場務。

<aside name="stage">

使用單面鏡以及其他的巧妙佈置，你可以真正地在同一*位置*佈置兩個舞臺。
隨着燈光切換，觀衆看到了不同的舞臺，無需看向不同的地方。
如何這樣佈置舞臺就留給讀者做練習吧。

</aside>

### 重新回到圖形

<span name="sync"></span>
這就是雙緩衝的工作原理，
這就是你看到的幾乎每個遊戲背後的渲染系統。
不只用一個幀緩衝，我們用*兩個*。其中一個代表現在的幀，即類比中的舞臺A，也就是說是顯卡讀取的那一個。
GPU可以想什麼時候掃就什麼時候掃。

<aside name="sync">

但不是*所有*的遊戲主機都是這麼做的。
更老的簡單主機中，內存有限，需要小心地同步繪製和渲染。那很需要技巧。

</aside>

同時，我們的渲染代碼正在寫入*另一個*幀緩衝。
即黑暗中的舞臺B。當渲染代碼完成了場景的繪製，它將通過*交換*緩存來切換燈光。
這告訴圖形硬件開始從第二塊緩存中讀取而不是第一塊。
只要在刷新之前交換，就不會有任何撕裂出現，整個場景都會一下子出現。

這時可以使用以前的幀緩衝了。我們可以將下一幀渲染在它上面了。超棒！

## 模式

定義*緩衝類*封裝了**緩衝**：一段可改變的狀態。
這個緩衝被增量地修改，但我們想要外部的代碼將修改視爲單一的原子操作。
爲了實現這點，類保存了*兩個*緩衝的實例：**下一緩衝**和**當前緩衝**。

當信息*從*緩衝區中讀取，它總是讀取*當前的*緩衝區。
當信息需要寫*到*緩存，它總是在*下一*緩衝區上操作。
當改變完成後，一個**交換**操作會立刻將當前緩衝區和下一緩衝區交換，
這樣新緩衝區就是公共可見的了。舊的緩衝區成爲下一個重用的緩衝區。

## 何時使用

這是那種你需要它時自然會想起的模式。
如果你有一個系統需要雙緩衝，它可能有可見的錯誤（撕裂之類的）或者行爲不正確。
但是，“當你需要時自然會想起”沒提提供太多有效信息。
更加特殊地，以下情況都滿足時，使用這個模式就很恰當：

* 我們需要維護一些被增量修改的狀態。
* 在修改到一半的時候，狀態可能會被外部請求。
* 我們想要防止請求狀態的外部代碼知道內部的工作方式。
* 我們想要讀取狀態，而且不想等着修改完成。

## 記住

不像其他較大的架構模式，雙緩衝模式位於底層。
正因如此，它對代碼庫的其他部分影響較小——大多數遊戲甚至不會感到有區別。
儘管這裏還是有幾個警告。

### 交換本身需要時間

在狀態被修改後，雙緩衝需要一個*swap*步驟。
這個操作必須是原子的——在交換時，沒有代碼可以接觸到*任何一個*狀態。
通常，這就是修改一個指針那麼快，但是如果交換消耗的時間長於修改狀態的時間，那可是毫無助益。

### 我們得保存兩個緩衝區

這個模式的另一個結果是增加了內存的使用。
正如其名，這個模式需要你在內存中一直保留*兩個*狀態的拷貝。
在內存受限的設備上，你可能要付出慘痛的代價。
如果你不能接受使用兩份內存，你需要使用別的方法保證狀態在修改時不會被請求。

## 示例代碼

我們知道了理論，現在看看它在實踐中如何應用。
我們編寫了一個非常基礎的圖形系統，允許我們在緩衝幀上描繪像素。
在大多數主機和電腦上，顯卡驅動提供了這種底層的圖形系統，
但是在這裏手動實現有助於理解發生了什麼。首先是緩衝區本身：

^code 1

它有將整個緩存設置成默認的顏色的操作，也將其中一個像素設置爲特定顏色的操作。
它也有函數`getPixels()`，讀取保存像素數據的數組。
雖然在這個例子中沒有出現，但在實際中，顯卡驅動會頻繁調用這個函數，將緩存中的數據輸送到屏幕上。

我們將整個緩衝區封裝在`Scene`類中。渲染某物需要做的是在這塊緩衝區上調用一系列`draw()`。

<span name="draw"></span>

^code 2

<aside name="draw">

特別地，它畫出來這幅曠世傑作：

<img src="images/double-buffer-face.png" width="240" alt="一個像素風的笑臉" />

</aside>

每一幀，遊戲告訴場景去繪製。場景清空緩衝區然後一個接一個繪製一大堆像素。
它也提供了`getBuffer()`獲得緩衝區，這樣顯卡可以接觸到它。

這看起來直截了當，但是如果就這樣做，我們會遇到麻煩。
顯卡驅動可以在*任何*時間調用`getBuffer()`，甚至在這個時候：

^code 3

當上面的情況發生時，用戶就會看到臉的眼睛，但是這一幀中嘴卻消失了。
下一幀，又可能在某些別的地方發生衝突。最終結果是糟糕的閃爍圖形。我們會用雙緩衝修復這點：

^code 4

現在`Scene`有存儲在`buffers_`數組中的兩個緩衝區，。
我們並不從數組中直接引用它們。而是通過兩個成員，`next_`和`current_`，指向這個數組。
當繪製時，我們繪製在`next_`指向的緩衝區上。
當顯卡驅動需要獲得像素信息時，它總是通過`current_`獲取*另一個*緩衝區。

通過這種方式，顯卡驅動永遠看不到我們正在施工的緩衝區。
解決方案的的最後一部分就是在場景完成繪製一幀的時候調用`swap()`。
它通過交換`next_`和`current_`的引用完成這一點。
下一次顯卡驅動調用`getBuffer()`，它會獲得我們剛剛完成渲染的新緩衝區，
然後將剛剛描繪好的緩衝區放在屏幕上。沒有撕裂，也沒有不美觀的問題。

### 不僅是圖形

雙緩衝解決的核心問題是狀態有可能在被修改的同時被請求。
這通常有兩種原因。圖形的例子覆蓋了第一種原因——另一線程的代碼或者另一箇中斷的代碼直接訪問了狀態。

但是，還有一個同樣常見的原因：*負責修改的* 代碼試圖訪問同樣正在修改狀態。
這可能發生在很多地方，特別是實體的物理部分和AI部分，實體在相互交互。
雙緩衝在那裏也十分有用。

### 人工不智能

假設我們正在構建一個關於趣味喜劇的遊戲的行爲系統。
這個遊戲包括一堆跑來跑去尋歡作樂的角色。這裏是我們的基礎角色：

^code 5

<span name="update"></span>

每一幀，遊戲要在角色身上調用`update()`，讓角色做些事情。
特別地，從玩家的角度，*所有的角色都應該看上去同時更新*。

<aside name="update">

這是<a class="pattern" href="update-method.html">更新方法</a>模式的例子。

</aside>

角色也可以相互交互，這裏的“交互”，我指“可以互相扇對方巴掌”。
當更新時，角色可以在另一個角色身上調用`slap()`來扇它一巴掌，然後調用`wasSlapped()`看看自己是不是被扇了。

角色需要一個可以交互的舞臺，讓我們來佈置一下：

^code 6

`Stage`允許我們向其中增加角色，
然後使用簡單的`update()`調用來更新每個角色。
在用戶看來，角色是同時移動的，但是實際上，它們是依次更新的。

這裏需要注意的另一點是，每個角色的“被扇”狀態在更新後就立刻被清除。
這樣才能保證一個角色對一巴掌只反應一次。

作爲一切的開始，讓我們定義一個具體的角色子類。
這裏的喜劇演員很簡單。
他只面向一個角色。當他被扇時——無論是誰扇的他——他的反應是扇他面前的人一巴掌。

^code 7

現在我們把一些喜劇演員丟到舞臺上看看發生了什麼。
我們設置三個演員，第一個面朝第二個，第二個面朝第三個，第三個面對第一個，形成一個環：

^code 8

最終舞臺佈置如下圖。箭頭代表角色的朝向，然後數字代表角色在舞臺數組中的索引。

<img src="images/double-buffer-slaps-1.png" alt="代表Harry，Baldy和Chump的三個盒子。Harry有一個指向 Baldy的箭頭，Baldy有個指向Chump的箭頭，Chump有個指向Harry的箭頭。" />

我們扇哈利一巴掌，爲表演拉開序幕，看看之後會發生什麼：

^code 9

記住`Stage`中的`update()`函數輪流更新每個角色，
因此如果檢視整個代碼，我們會發現事件這樣發生：

    Stage updates actor 0 (Harry)
      Harry was slapped, so he slaps Baldy
    Stage updates actor 1 (Baldy)
      Baldy was slapped, so he slaps Chump
    Stage updates actor 2 (Chump)
      Chump was slapped, so he slaps Harry
    Stage update ends

在單獨的一幀中，初始給哈利的一巴掌傳給了所有的喜劇演員。
現在，讓事物複雜起來，讓我們重新排列舞臺數組中角色的排序，
但是繼續保持面向對方的方式。

<img src="images/double-buffer-slaps-2.png" alt="還是相同的盒子和箭頭，只是順序變成了Chump, Baldy, Harry." />

我們不動舞臺的其餘部分，只是將添加角色到舞臺的代碼塊改爲如下：

^code 10

讓我們看看再次運行時會發生什麼：

    Stage updates actor 0 (Chump)
      Chump was not slapped, so he does nothing
    Stage updates actor 1 (Baldy)
      Baldy was not slapped, so he does nothing
    Stage updates actor 2 (Harry)
      Harry was slapped, so he slaps Baldy
    Stage update ends

<span name="cascade"></span>

哦不。完全不一樣了。問題很明顯。
更新角色時，我們修改了他們的“被扇”狀態，這也是我們在更新時*讀取*的狀態。
因此，在更新中早先的狀態修改會影響之後*同一*狀態的修改的步驟。

<aside name="cascade">

如果你繼續更新舞臺，你會看到巴掌在角色間逐漸傳遞，每幀傳遞一個。
在第一幀 Harry扇了Baldy。下一幀，Baldy扇了Chump，如此類推。

</aside>

而最終的結果是，一個角色對被扇作出反應可能是在被扇的*同一*幀或者*下一*幀，
這完全取決於兩個角色在舞臺上是如何排序的。
這沒能滿足我讓角色同時反應的需求——它們在同一幀中更新的順序不該對結果有影響。

### 緩存巴掌

幸運的是，雙緩衝模式可以幫忙。
這次，不是保存兩大塊“緩衝”，我們緩衝更小粒度的事物：每個角色的“被扇”狀態。

^code 11

不再使用一個`slapped_`狀態，每個演員現在使用兩個。
就像我們之前圖形的例子一樣，當前狀態爲讀準備，下一狀態爲寫準備。

`reset()`函數被替換爲`swap()`。
現在，就在清除交換狀態前，它將下一狀態拷貝到當前狀態上，
使其成爲新的當前狀態，這還需要在`Stage`中進行小小的改變：

^code 12

`update()`函數現在更新所有的角色，*然後* 交換它們的狀態。
最終結果是，角色在實際被扇*之後*的那幀才能看到巴掌。
這樣一來，角色無論在舞臺數組中如何排列，都會保持相同的行爲。
無論外部的代碼如何調用，所有的角色在一幀內同時更新。

## 設計決策

雙緩衝很直觀，我們上面看到的例子也覆蓋了大多數你需要的場景。
使用這個模式之前，還需要做兩個主要的設計決策。

### 緩衝區是如何被交換的？

交換操作是整個過程的最重要的一步，
因爲在其發生時，我們必須鎖住兩個緩衝區上的讀取和修改。
爲了讓性能最優，我們需要它進行得越快越好。

* **交換緩衝區的指針或者引用：**
    這是我們圖形例子中的做法，這也是大多數雙緩衝圖形通用的解決方法。

    * *速度快。* 不管緩衝區有多大，交換都只需賦值一對指針。很難在速度和簡易性上超越它。

    * *外部代碼不能存儲對緩存的永久指針。* 這是主要限制。
      由於我們沒有真正地移動*數據*，本質上做的是週期性地通知代碼庫的其他部分到別處去尋找緩存，
      就像前面的舞臺類比一樣。這就意味着代碼庫的其他部分不能存儲指向緩衝區中數據的指針——
      它一段時間後可能就指向了錯誤的部分。

        這會嚴重誤導那些期待緩衝幀永遠在內存中的固定地址的顯卡驅動。在這種情況下，我們不能這麼做。

    *  *緩衝區中的數據是兩幀之前的數據，而不是上一幀的數據。*
      接下來的那幀繪製在幀緩衝區上，而不是在它們之間拷貝數據，就像這樣：

            :::text
            Frame 1 drawn on buffer A
            Frame 2 drawn on buffer B
            Frame 3 drawn on buffer A
            ...

        <span name="blur"></span>
        你會注意到，當我們繪製第三幀時，緩衝區上的數據是*第一幀*的，而不是第二幀的。大多數情況下，這不是什麼問題——我們通常在繪製之前清空整個幀。但如果想沿用某些緩存中已有的數據，就需要考慮數據其實比期望的更舊。

        <aside name="blur">

        舊幀中緩存數據的經典用法是模擬動態模糊。
        當前的幀混合一點之前的幀，看起來更像真實的相機捕獲的圖景。

        </aside>

* **在緩衝區之間拷貝數據：**
    如果我們不能重定向到其他緩存，唯一的選項就是將下幀的數據實實在在的拷貝到現在這幀上。
    這是我們的扇巴掌喜劇的工作方法。
    這種情況下，使用這種方法是因爲拷貝狀態——一個簡單的布爾標識——不比修改指向緩存的指針開銷大。

    * *下一幀的數據和之前的數據相差一幀。*
      拷貝數據與在兩塊緩衝區間跳來跳去正相反。
      如果我們需要前一幀的數據，這樣我們可以處理更新的數據。

    * *交換也許更花時間。*
      這個當然是最大的缺點。交換操作現在意味着在內存中拷貝整個緩衝區。
      如果緩衝區很大，比如一整個緩衝幀，這需要花費可觀的時間。
      由於交換時沒有東西可以讀取或者寫入*任何一個*緩衝區，這是一個巨大的限制。

### 緩衝的粒度如何？

這裏的另一個問題是緩衝區本身是如何組織的——是單個數據塊還是散佈在對象集合中？
圖形例子是前一種，而角色例子是後一種。

大多數情況下，你緩存的方式自然而然會引導你找到答案，但是這裏也有些靈活度。
比如，角色總能將消息存在獨立的消息塊中，使用索引來引用。

* **如果緩存是一整塊：**

    * *交換操作更簡單。*
      由於只有一對緩存，一個簡單的交換就完成了。
      如果可以改變指針來交換，那麼不必在意緩衝區大小，只需幾部操作就可以交換整個緩衝區。</p>

* **如果很多對象都持有一塊數據：**

    * *交換操作更慢。*
      爲了交換，需要遍歷整個對象集合，通知每個對象交換。

        在喜劇的例子中，這沒問題，因爲反正需要清除被扇狀態
        ——每塊緩存的數據每幀都需要接觸。
        如果不需要接觸較舊的幀，可以用通過在多個對象間分散狀態來優化，獲得使用整塊緩存一樣的性能。

        思路是將“當前”和“下一”指針概念，將它們改爲對象相關的*偏移量*。就像這樣：

        ^code 13

        角色使用`current_`在狀態數組中查詢，獲得當前的被扇狀態，
        下一狀態總是數組中的另一索引，這樣可以用`next()`來計算。
        交換狀態只需改動`current_`索引。
        聰明之處在於`swap()`現在是*靜態*函數，它只需被調用一次，*每個* 角色的狀態都會被交換。

## 參見

* 你可以在幾乎每個圖形API中找到雙緩衝模式。舉個例子，OpenGL有`swapBuffers()`，Direct3D有"swap chains", Microsoft的XNA框架有`endDraw()`方法。
