^title 對象池模式 Object Pool
^section Optimization Patterns

## 意圖

*放棄單獨地分配和釋放對象，從固定的池中重用對象，以提高性能和內存使用率*

## 動機

我們在處理遊戲的視覺效果。
當英雄釋放了法術，我們想要在屏幕上爆發閃光。
這需要調用*粒子系統*，產生動態的閃爍圖形，顯示動畫直到圖形消失。

由於一次簡單的魔杖揮舞就能產生成百上千的粒子，系統需要能夠快速地生成它們。
更重要的是，我們需要保證創建和銷燬這些粒子不會造成*內存碎片*。

### 碎片的詛咒

爲遊戲主機或者移動設備編程在許多方面比爲普通的計算機編程更像是嵌入式編程。
內存緊張，玩家希望遊戲能如磐石般穩定運行，壓縮內存的管理器很難有效。
在這種環境下，內存碎片是致命的。

<span name="park"></span>

碎片意味着在堆中的空餘空間被打碎成了很多小的內存碎片，而不是大的連續內存塊。
*總共的* 可用內存也許很大，但是最長的*連續*空間可能難以忍受地小。
假設我們有十四個空餘字節，但是被一塊正在使用的內存分割成了兩個七字節的碎片。
而我們嘗試分配十二字節的對象，那麼就會失敗。屏幕上不會有更多的閃爍火花了。

<aside name="park">

這有點像在已經停了很多車的繁忙街道上停車。
如果它們擠在一起，儘管空間還是有剩餘的，但空閒地帶變成了車之間的*碎片*空間。

</aside>

<span name="heap"></span>

<img src="images/object-pool-heap-fragment.png" alt="一系列導致碎片化的內存操作。" />

<aside name="heap">

這裏展現了堆是怎麼碎片化的，以及即使在理論上有足夠的可用內存，內存也會分配失敗。

</aside>

<span name="soak"></span>

哪怕碎片化發生得不頻繁，它也仍會逐漸把堆變成有空洞和裂隙的不可用泡沫，最終完全無法運行遊戲。

<aside name="soak">

大多數主機遊戲製作商要求遊戲通過“浸泡測試”，即讓遊戲在demo模式運行上幾天。
如果遊戲崩潰了，他們不允許遊戲發售。
浸泡測試失敗有時是因爲發生罕見的漏洞，但碎片增長或者內存泄露是造成遊戲停止的大部分原因。

</aside>

### 兼得魚和熊掌

由於碎片化和可能很慢的內存分配，遊戲中何時何處管理內存通常需要十分小心。
一個簡單又有效的辦法是——遊戲開始時取一大塊內存，然後直到遊戲結束纔去釋放它。
但是這對要在遊戲運行時創建和銷燬事物的系統來說是痛苦的。

使用對象池能讓我們兼得魚和熊掌。
對內存管理器，我們只需要將一大塊內存分出來，保持在遊戲運行時不釋放它。
對於池的使用者，我們可以簡單地構造析構我們想要的內容對象。

## 模式

定義一個**池**對象，其包含了一組**可重用對象**。
其中每個可重用對象都支持**查詢“使用中”狀態**，說明它是不是“正在使用”。
池被初始化時，它就創建了整個對象集合（通常使用一次連續的分配），然後初始化所有對象到“不在使用中”狀態。

當你需要新對象，向池子要一個。
它找到一個可用對象，初始化爲“使用中”然後返回。
當對象不再被需要，它被設置回“不在使用中”。
通過這種方式，可以輕易地創建和銷燬對象而不必分配內存或其他資源。

## 何時使用

這個模式廣泛應用於可見的事物上，比如遊戲實體和視覺效果，
但是它也可在不那麼視覺化的數據結構上使用，比如正在播放的聲音。
在以下情況中使用對象池：

* 需要頻繁創建和銷燬對象。

* 對象大小相仿。

* 在堆上進行對象內存分配十分緩慢或者會導致內存碎片。

* 每個對象都封裝了像數據庫或者網絡連接這樣很昂貴又可以重用的資源。

## 記住

你通常依賴垃圾回收機制或者`new`和`delete`來處理內存管理。
通過使用對象池，你是在說，“我知道如何更好地處理這些字節。”
這就意味着處理內存的責任落到了你頭上。

### 池可能在不需要的對象上浪費內存

對象池的大小需要根據遊戲的需求設置。
當池子太*小*時，很明顯需要調整（沒有什麼比崩潰更能獲得你的注意力了）。
但是也要小心確保池子沒有太*大*。更小的池子提供了空餘的內存做其他有趣的事情。

### 同時只能激活固定數量的對象

在某種程度上這是好事。
將內存按不同的對象類型劃分單獨的池保證了這點。
舉個例子，一連串爆炸不會讓粒子系統消耗掉*所有*可用內存，然後阻礙創建新敵人這樣的關鍵事件。

儘管如此，這也意味着試圖從池子重用對象可能會失敗，因爲它們都在使用中。
這裏有幾個常見對策：

* *完全阻止這點。*
  這是通常的“修復”：增加對象池的大小，這樣無論用戶做什麼，它們都不會溢出。
  對於重要對象，比如敵人或遊戲道具，這通常是正確的選擇。
  也許沒有“正確的”方法來處理玩家抵達關底時創建巨大Boss內存不足的問題，所以最聰明的辦法就是保證這不發生。

    這個的副作用是強迫你爲那些只在一兩個罕見情況下需要的對象分配過多的內存。
    因此，固定大小的對象池也許不對所有的遊戲狀態都適用。
    舉個例子，某些關卡也許需要更多的效果而其他的需要聲音。
    在這種情況下，考慮爲每個場景調整對象池的大小。

* *就不要創建對象了。*
  這聽起來很糟，但是對於像粒子系統這樣的情況很有道理。
  如果所有的粒子都在使用，那麼屏幕已經充滿了閃動的圖形。
  用戶不會注意到下個爆炸不如現在的這個一樣引人注目。

* *強制幹掉一個已有的對象。*
  想想正在播放聲音的內存池，假設需要播放新聲音而對象池滿了。
  你*不想*簡單地忽視新聲音——用戶會注意到魔法劍有時會發齣戲劇般的聲音，有時頑固地一聲不吭。
  更好的解決方法是找到播放中最輕的聲音，然後用新聲音替代之。新聲音會覆蓋掉前一個聲音。

    大體上，如果已有對象的*消失*要比新對象的*出現*更不引人察覺，這也許是正確的選擇。

* *增加池的大小。*
  如果遊戲允許你使用一點內存上的靈活性，我們也許會在運行時增加池子的大小或者創建新的溢出池。
  如果用這種方式獲取內存，考慮下在增加的內存不再需要時，池是否需要縮回原來的大小。

### 每個對象的內存大小是固定的

多數對象池將對象存儲在一個數組中。
如果你所有的對象都是同樣的類型，這很好。
但是，如果你想要在同一個對象池中存儲不同類型的對象，或者存儲子類的實例，
你需要保證池中的每個位置對*最大的*可能對象都有足夠的內存。
否則，超過預期大小的對象會佔據下一個對象的內存空間，導致內存崩壞。

同時，如果對象大小是變化的，你是在浪費內存。
每個槽都需要能存儲最大的對象。
如果對象很少那麼大，每放進去一個小對象都是在浪費內存。
這很像是通過機場安檢時，使用最大允許尺寸的箱子，而裏面只放了鑰匙和錢包。

<span name="pools"></span>

當你發現自己在用這種方式浪費內存，考慮將池根據對象的大小分割爲分離的池
——大箱子給大行李，小箱子給口袋裏的東西。

<aside name="pools">

這是一種實現有效率的內存管理的常用模式。
管理者擁有一系列池，池的塊大小不相同。
當你申請分配一塊，它會從合適塊大小的池中取出一塊，然後分配給你。

</aside>

### 重用對象不會自動清除。

很多內存管理系統擁有debug特性，會清除或釋放所有內存成特定的值，比如`0xdeadbeef`。
這幫助你找到使用未初始化變量或使用已被釋放內存造成的痛苦漏洞。

由於對象池重用對象不再經過內存管理系統，我們失去了這層安全網。
更糟的是，爲“新”對象使用的內存之前存儲的是同樣類型的對象。
這使你很難分辨出創建新對象時的未初始化問題：
那個存儲新對象的內存已經保存了來自於上個生命週期中的*幾乎完全*正確的數據。

<span name="clear"></span>

由於這點，特別注意在池裏初始化對象的代碼，保證它*完全*地初始化了對象。
甚至很值得加個在對象回收時清空對象槽的debug選項。

<aside name="clear">

如果你將其清空爲`0x1deadb0b`，我會很榮幸的。

</aside>

### 未使用的對象會保留在內存中

對象池在支持垃圾回收的系統中很少見，因爲內存管理系統通常會爲你處理這些碎片。
但是對象池仍然是避免構建和析構的有用手段，特別是在有更慢CPU和更簡陋垃圾回收系統的移動設備上。

如果你使用有垃圾回收的對象池系統，注意潛在的衝突。
由於池不會在對象不再使用時真正地析構它們，如果對象仍然保留任何對*其他*對象的引用，也會阻止垃圾回收器回收它。
爲了避免這點，當池中對象不再使用，清除它對其他對象的所有引用。

## 示例代碼

現實世界的粒子系統通常應用重力，風，摩擦，和其他物理效果。
我們簡陋的例子只在直線上移動粒子幾幀，然後銷燬粒子。
這不是工業級的代碼，但足夠說明如何使用對象池。

我們應該從最簡單的可能實現開始。首先是小小的粒子類：

^code 1

默認的構造器將粒子初始化爲“不在使用中”。之後對`init()`的調用初始化粒子到活躍狀態。
粒子隨着時間播放動畫，一幀調用一次`animate()`函數。

對象池需要知道哪個粒子可以被重用。它通過粒子的`inUse()`函數獲知這點。
這個函數利用了粒子生命時間有限這點，並使用變量`framesLeft_`來決定哪些粒子在被使用，無需存儲分離的標識。

對象池類也很簡單：

^code 2

<span name="update"></span>

`create()`函數允許外部代碼創建新粒子。
遊戲每幀調用`animate()`一次，讓對象池中的粒子輪流顯示動畫。

<aside name="update">

`animate()`方法是<a href="update-method.html" class="pattern">更新方法</a>模式的一個例子。

</aside>

粒子本身被存儲在對象池類中一個固定大小的數組裏。
在這個簡單的實現中，池的大小在類聲明時被硬編碼了，但是也可以使用動態大小的數組或使用由外部定義的模板變量。

創建新粒子很直觀：

^code 3

我們遍歷對象池找到第一個可用粒子。
當我們找到後，初始化它然後就完成了。
注意在這個實現中，如果這裏沒有找到任何可用的粒子，就不創建新的粒子。

做一個簡單粒子系統的所有東西都在這裏了，當然，沒有包含渲染粒子。
我們現在可以創建對象池然後使用它創建粒子。當時間到了，粒子會自動失效。

<span name="create"></span>

這足夠承載一個遊戲了，但是敏銳的讀者也許會注意到創建新粒子（可能）需要遍歷整個集合，直到找到一個空閒槽。
如果池很大很滿，這可能很慢。
讓我們看看可以怎樣改進這一點。

<aside name="create">

創建一個粒子的複雜度是*O(n)* ，上過算法課的人都知道。

</aside>

### 空閒列表

如果不想浪費時間在*查找*空閒粒子上，明顯的解決方案是不要失去對它們的追蹤。
我們可以存儲指向每個未使用粒子的單獨指針列表。
然後，當需要創建粒子時，我們從列表中移除第一個指針，然後重用它指向的粒子。

不幸的是，這回要我們管理一個和對象池同樣大小的單獨數組。
無論如何，在我們創建池時，*所有的* 粒子都未被使用，所以列表初始會包含池中每個對象的指針。

如果*無需*犧牲任何內存就能修復性能問題那就好了。
方便的是，這裏已經有可以借用的內存了——那些未使用粒子自身的內存。

當粒子未被使用時，它的大部分的狀態都是無關緊要的。
它的位置和速度沒有被使用。唯一需要的是表示自身是否激活的狀態。
在我們的例子中，那是`framesLeft_`成員。
其他的所有位都可以被重用。這裏是改進後的粒子：

^code 4

<span name="union"></span>

我們將除`framesLeft_`外的所有成員變量移到`live`結構中，而該結構存儲在union`state_`中。
這個結構保存粒子在播放動畫時的狀態。
當粒子被重用時，union的其他部分，`next`成員被使用了。
它保留了一個指向這個粒子後面的可用粒子的指針。

<aside name="union">

Unions近些年不那麼常見了，所以你可能不熟悉這些語法。
如果你在遊戲團隊中，你可能會遇見“內存大師”，當遊戲遇到不可避免的內存耗盡問題時，他們就挺身而出。
問問他們關於unions的事。
他們知道所有有關union的事情，還有其他有趣的位壓縮技巧。

</aside>

我們可以使用這些指針構建鏈表，將池中每個未使用的粒子都連在一起。
我們有可用粒子的列表，而且無需使用額外的內存。
我們使用了死亡粒子本身的內存來存儲列表。

這種聰明的技術被稱爲[*freelist*](http://en.wikipedia.org/wiki/Free_list)。
爲了讓其工作，我們需要保證指針正確地初始化，在粒子創建和銷燬時好好被管理了。
並且，當然，我們要追蹤列表的頭指針：

^code 5

當首次創建對象池時，*所有的* 粒子都是可用的，所以空餘列表應該貫穿整個對象池。對象池構造器設置了這些：

^code 6

<span name="first"></span>

現在爲了創建新粒子，我們直接跳到首個可用的粒子：

<aside name="first">

*O(1)* 複雜度，孩子！這才叫編碼！

</aside>

^code 7

我們需要知道粒子何時死亡，這樣可將其放回到空閒列表中，
所以我們將`animate()`改爲在粒子不再活躍時返回`true`：

^code particle-animate

當那發生時，簡單地將其放回列表：

^code 8

這樣就成了，一個小對象池，擁有常量時間的構造和刪除。

## 設計決策

如你所見，對象池最簡單的實現非常平凡：創建對象數組，在需要它們時重新初始化。
實際的代碼很少會那麼簡單，這裏還有很多方式讓池更加的通用，安全，或容易管理。
在遊戲中實現對象池時，你需要回答以下問題：

### 對象和池耦合嗎？

寫對象池時第一個需要思考的問題：對象本身是否需要知道它們在池子中。
大多數情況下它們需要，但是那樣你就不大可能寫一個通用對象池類來保存任意對象。

* **如果對象與池耦合：**

    * *實現更簡單。*
      你可以在對象中簡單地放個“在使用中”標識或者函數，就完成了。

    * *你可以保證對象只能被對象池創建。*
      在C++中，做這事最簡單的方法是讓池對象是對象類的友類，將對象的構造器設爲私有。

        ^code 10

        在類間保持這種關係來確保使用者無法創建對象池沒有追蹤的對象。

    * *你也許可以避免顯式存儲“使用中”的標識。*
      很多對象已經保存了可以告訴外界它有沒有在使用的狀態。
      舉個例子，粒子的位置如果不在屏幕上，也許它就可以被重用。
      如果對象類知道它在對象池中，那它可以提供一個`inUse()`來查詢這個狀態。
      這省下了對象池存儲“在使用中”標識的多餘內存。

* **如果對象沒有和對象池耦合：**

    * *可以保存多種類型的對象。*
      這是最大的好處。通過解耦對象和對象池，你可以實現通用的、可重用的對象池類。

    * *必須在對象的外部追蹤“使用中”狀態。*
      做這點最簡單的方式是創建分離的位字段：

        ^code 11

### 誰負責初始化重用對象？

爲了重用一個已經存在的對象，它必須用新狀態重新初始化。
這裏的關鍵問題是你需要在對象池的內部還是外部重新初始化。

* **如果在對象池的內部重新初始化：**

    * *對象池可以完全封裝管理對象。*
      取決於對象需要的其他能力，你可以讓它們完全處於池的內部。
      這保證了其外部代碼不會引用到已重用的對象。

    * *對象池與對象是如何初始化的相綁定。*
      池中對象也許提供了不同的初始化函數。
      如果對象池控制了初始化，它的接口需要支持所有的初始化函數，然後轉發給對象。

        ^code 12

* **如果外部代碼初始化對象：**

    * *對象池的接口更簡單。*
      無需提供覆蓋每種對象初始化的多種函數，對象池只需要返回新對象的引用：

        ^code 13

        調用者可以使用對象暴露的任何方法進行初始化：

        ^code 14

    * *外部代碼需要處理無法創建新對象的失敗。*
      前面的例子假設`create()`總能成功地返回一個指向對象的指針。
      但如果對象池已經滿了，返回的會是`NULL`。安全起見，你需要在初始化之前檢查這一點。

        ^code 15

## 參見

* 這看上去很像是<a class="gof-pattern" href="flyweight.html">享元</a>模式。
  兩者都控制了一系列可重用的對象。不同在於“重用”的含義。
  享元對象分享實例間*同時*擁有的相同部分。享元模式在不同上下文中使用相同對象避免了*重複*內存使用。

    對象池中的對象也被重用了，但是是在不同的時間點上被重用的。
    “重用”在對象池中意味着對象在原先的對象用完*之後*分配內存。
    對象池沒有期待對象會在它的生命週期中分享什麼。

* 將內存中同樣類型的對象進行整合，能確保在遍歷對象時CPU緩存總是滿的。
  <a class="pattern" href="data-locality.html">數據局部性</a>模式介紹了這一點。
